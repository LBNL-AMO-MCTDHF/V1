!!$
!!$Apache License
!!$                           Version 2.0, January 2004
!!$                        http://www.apache.org/licenses/
!!$
!!$   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
!!$
!!$   1. Definitions.
!!$
!!$      "License" shall mean the terms and conditions for use, reproduction,
!!$      and distribution as defined by Sections 1 through 9 of this document.
!!$
!!$      "Licensor" shall mean the copyright owner or entity authorized by
!!$      the copyright owner that is granting the License.
!!$
!!$      "Legal Entity" shall mean the union of the acting entity and all
!!$      other entities that control, are controlled by, or are under common
!!$      control with that entity. For the purposes of this definition,
!!$      "control" means (i) the power, direct or indirect, to cause the
!!$      direction or management of such entity, whether by contract or
!!$      otherwise, or (ii) ownership of fifty percent (50%) or more of the
!!$      outstanding shares, or (iii) beneficial ownership of such entity.
!!$
!!$      "You" (or "Your") shall mean an individual or Legal Entity
!!$      exercising permissions granted by this License.
!!$
!!$      "Source" form shall mean the preferred form for making modifications,
!!$      including but not limited to software source code, documentation
!!$      source, and configuration files.
!!$
!!$      "Object" form shall mean any form resulting from mechanical
!!$      transformation or translation of a Source form, including but
!!$      not limited to compiled object code, generated documentation,
!!$      and conversions to other media types.
!!$
!!$      "Work" shall mean the work of authorship, whether in Source or
!!$      Object form, made available under the License, as indicated by a
!!$      copyright notice that is included in or attached to the work
!!$      (an example is provided in the Appendix below).
!!$
!!$      "Derivative Works" shall mean any work, whether in Source or Object
!!$      form, that is based on (or derived from) the Work and for which the
!!$      editorial revisions, annotations, elaborations, or other modifications
!!$      represent, as a whole, an original work of authorship. For the purposes
!!$      of this License, Derivative Works shall not include works that remain
!!$      separable from, or merely link (or bind by name) to the interfaces of,
!!$      the Work and Derivative Works thereof.
!!$
!!$      "Contribution" shall mean any work of authorship, including
!!$      the original version of the Work and any modifications or additions
!!$      to that Work or Derivative Works thereof, that is intentionally
!!$      submitted to Licensor for inclusion in the Work by the copyright owner
!!$      or by an individual or Legal Entity authorized to submit on behalf of
!!$      the copyright owner. For the purposes of this definition, "submitted"
!!$      means any form of electronic, verbal, or written communication sent
!!$      to the Licensor or its representatives, including but not limited to
!!$      communication on electronic mailing lists, source code control systems,
!!$      and issue tracking systems that are managed by, or on behalf of, the
!!$      Licensor for the purpose of discussing and improving the Work, but
!!$      excluding communication that is conspicuously marked or otherwise
!!$      designated in writing by the copyright owner as "Not a Contribution."
!!$
!!$      "Contributor" shall mean Licensor and any individual or Legal Entity
!!$      on behalf of whom a Contribution has been received by Licensor and
!!$      subsequently incorporated within the Work.
!!$
!!$   2. Grant of Copyright License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      copyright license to reproduce, prepare Derivative Works of,
!!$      publicly display, publicly perform, sublicense, and distribute the
!!$      Work and such Derivative Works in Source or Object form.
!!$
!!$   3. Grant of Patent License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      (except as stated in this section) patent license to make, have made,
!!$      use, offer to sell, sell, import, and otherwise transfer the Work,
!!$      where such license applies only to those patent claims licensable
!!$      by such Contributor that are necessarily infringed by their
!!$      Contribution(s) alone or by combination of their Contribution(s)
!!$      with the Work to which such Contribution(s) was submitted. If You
!!$      institute patent litigation against any entity (including a
!!$      cross-claim or counterclaim in a lawsuit) alleging that the Work
!!$      or a Contribution incorporated within the Work constitutes direct
!!$      or contributory patent infringement, then any patent licenses
!!$      granted to You under this License for that Work shall terminate
!!$      as of the date such litigation is filed.
!!$
!!$   4. Redistribution. You may reproduce and distribute copies of the
!!$      Work or Derivative Works thereof in any medium, with or without
!!$      modifications, and in Source or Object form, provided that You
!!$      meet the following conditions:
!!$
!!$      (a) You must give any other recipients of the Work or
!!$          Derivative Works a copy of this License; and
!!$
!!$      (b) You must cause any modified files to carry prominent notices
!!$          stating that You changed the files; and
!!$
!!$      (c) You must retain, in the Source form of any Derivative Works
!!$          that You distribute, all copyright, patent, trademark, and
!!$          attribution notices from the Source form of the Work,
!!$          excluding those notices that do not pertain to any part of
!!$          the Derivative Works; and
!!$
!!$      (d) If the Work includes a "NOTICE" text file as part of its
!!$          distribution, then any Derivative Works that You distribute must
!!$          include a readable copy of the attribution notices contained
!!$          within such NOTICE file, excluding those notices that do not
!!$          pertain to any part of the Derivative Works, in at least one
!!$          of the following places: within a NOTICE text file distributed
!!$          as part of the Derivative Works; within the Source form or
!!$          documentation, if provided along with the Derivative Works; or,
!!$          within a display generated by the Derivative Works, if and
!!$          wherever such third-party notices normally appear. The contents
!!$          of the NOTICE file are for informational purposes only and
!!$          do not modify the License. You may add Your own attribution
!!$          notices within Derivative Works that You distribute, alongside
!!$          or as an addendum to the NOTICE text from the Work, provided
!!$          that such additional attribution notices cannot be construed
!!$          as modifying the License.
!!$
!!$      You may add Your own copyright statement to Your modifications and
!!$      may provide additional or different license terms and conditions
!!$      for use, reproduction, or distribution of Your modifications, or
!!$      for any such Derivative Works as a whole, provided Your use,
!!$      reproduction, and distribution of the Work otherwise complies with
!!$      the conditions stated in this License.
!!$
!!$   5. Submission of Contributions. Unless You explicitly state otherwise,
!!$      any Contribution intentionally submitted for inclusion in the Work
!!$      by You to the Licensor shall be under the terms and conditions of
!!$      this License, without any additional terms or conditions.
!!$      Notwithstanding the above, nothing herein shall supersede or modify
!!$      the terms of any separate license agreement you may have executed
!!$      with Licensor regarding such Contributions.
!!$
!!$   6. Trademarks. This License does not grant permission to use the trade
!!$      names, trademarks, service marks, or product names of the Licensor,
!!$      except as required for reasonable and customary use in describing the
!!$      origin of the Work and reproducing the content of the NOTICE file.
!!$
!!$   7. Disclaimer of Warranty. Unless required by applicable law or
!!$      agreed to in writing, Licensor provides the Work (and each
!!$      Contributor provides its Contributions) on an "AS IS" BASIS,
!!$      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
!!$      implied, including, without limitation, any warranties or conditions
!!$      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
!!$      PARTICULAR PURPOSE. You are solely responsible for determining the
!!$      appropriateness of using or redistributing the Work and assume any
!!$      risks associated with Your exercise of permissions under this License.
!!$
!!$   8. Limitation of Liability. In no event and under no legal theory,
!!$      whether in tort (including negligence), contract, or otherwise,
!!$      unless required by applicable law (such as deliberate and grossly
!!$      negligent acts) or agreed to in writing, shall any Contributor be
!!$      liable to You for damages, including any direct, indirect, special,
!!$      incidental, or consequential damages of any character arising as a
!!$      result of this License or out of the use or inability to use the
!!$      Work (including but not limited to damages for loss of goodwill,
!!$      work stoppage, computer failure or malfunction, or any and all
!!$      other commercial damages or losses), even if such Contributor
!!$      has been advised of the possibility of such damages.
!!$
!!$   9. Accepting Warranty or Additional Liability. While redistributing
!!$      the Work or Derivative Works thereof, You may choose to offer,
!!$      and charge a fee for, acceptance of support, warranty, indemnity,
!!$      or other liability obligations and/or rights consistent with this
!!$      License. However, in accepting such obligations, You may act only
!!$      on Your own behalf and on Your sole responsibility, not on behalf
!!$      of any other Contributor, and only if You agree to indemnify,
!!$      defend, and hold each Contributor harmless for any liability
!!$      incurred by, or claims asserted against, such Contributor by reason
!!$      of your accepting any such warranty or additional liability.
!!$
!!$   END OF TERMS AND CONDITIONS
!!$
!!$   Copyright 2017 the regents of the University of California
!!$
!!$   Licensed under the Apache License, Version 2.0 (the "License");
!!$   you may not use this file except in compliance with the License.
!!$   You may obtain a copy of the License at
!!$
!!$       http://www.apache.org/licenses/LICENSE-2.0
!!$
!!$   Unless required by applicable law or agreed to in writing, software
!!$   distributed under the License is distributed on an "AS IS" BASIS,
!!$   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!$   See the License for the specific language governing permissions and
!!$   limitations under the License.


#include "Definitions.INC"


subroutine transferparams(innumspf,inspfrestrictflag,inspfmvals,inspfugrestrict,&
     inspfugvals,outspfsmallsize,outorbparflag)
  use myparams
  implicit none
  integer :: innumspf,inspfrestrictflag,inspfmvals(innumspf), inspfugrestrict,&
       inspfugvals(innumspf), outspfsmallsize,ii
  logical, intent(out) :: outorbparflag

  numspf=innumspf;  
  outspfsmallsize=totpoints
  outorbparflag=orbparflag

  ii=inspfrestrictflag; ii=inspfmvals(1); ii=inspfugvals(1); ii=inspfugrestrict;

end subroutine transferparams


subroutine twoedealloc()
end subroutine twoedealloc


module mycdotmod
contains
  recursive function mycdot(one,two,n)
    implicit none
    integer,intent(in) :: n
    DATATYPE,intent(in) :: one(n), two(n)
    DATATYPE :: mycdot, sum
    integer :: i
    sum=0.d0
    do i=1,n
       sum = sum + one(i) * two(i) 
    enddo
    mycdot=sum
  end function mycdot
  recursive function mydot(one,two,n)
    implicit none
    integer,intent(in) :: n
    DATATYPE,intent(in) :: one(n), two(n)
    DATATYPE :: mydot, sum
    integer :: i
    sum=0.d0
    do i=1,n
       sum = sum + CONJUGATE(one(i)) * two(i) 
    enddo
    mydot=sum
  end function mydot
end module


module tinvsubmod
contains

subroutine  op_tinv(twoeden03,twoereduced,allsize,circsize,&
     times1,times3,times4,times5,fttimes)
  use myparams
  use myprojectmod
  implicit none
  integer, intent(in) :: allsize,circsize
  integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
  DATATYPE,intent(in) :: twoeden03(totpoints,allsize)
  DATATYPE,intent(out) :: twoereduced(totpoints,allsize)

  if (debugflag.eq.4040.or.debugflag.eq.4242.or.debugflag.eq.4343) then
     twoereduced=0d0
     return
  endif

!!$TINV  if (scalingflag.eq.0) then

  call op_tinv_notscaled(twoeden03,twoereduced,allsize,circsize,&
       times1,times3,times4,times5,fttimes)


!!$TINV  else
!!$TINV     call op_tinv_scaled(twoeden03,twoereduced,allsize,circsize,&
!!$TINV     times1,times3,times4,times5,fttimes)
!!$TINV  endif

contains

!!$TINV  !! w = weights e^3itheta
!!$TINV  !! c = weights^1/3
!!$TINV  !!
!!$TINV  !! reduced = w^-1/2 T-twiddle^-1 w^-1/2 den
!!$TINV  !!         = c^-3/2 T-twiddle^-1 c^-3/2 den
!!$TINV  !!
!!$TINV  !! T-twiddle c^3/2 reduced = c^-3/2 den
!!$TINV  !!
!!$TINV  !! c T-twiddle c c^1/2 reduced = c^-1/2 den
!!$TINV  !!
!!$TINV  !! ( c T-twiddle c T^-1) (T c^1/2 reduced) = c^-1/2 den
!!$TINV  !!
!!$TINV  !! ( c T-twiddle c T^-1) = 1 + (c T-twiddle c - T) T^-1
!!$TINV  
!!$TINV  subroutine  op_tinv_scaled(twoeden03,twoereduced,allsize,circsize,&
!!$TINV       times1,times3,times4,times5,fttimes)
!!$TINV    use myparams
!!$TINV    use pfileptrmod
!!$TINV    use myprojectmod
!!$TINV    implicit none
!!$TINV    integer, intent(in) :: allsize,circsize
!!$TINV    integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
!!$TINV    DATATYPE,intent(in) :: twoeden03(totpoints,allsize)
!!$TINV    DATATYPE,intent(out) :: twoereduced(totpoints,allsize)
!!$TINV    DATATYPE :: temp(totpoints,allsize)
!!$TINV    integer :: ii,numcalled,ierr
!!$TINV    external :: scaled_operate_sub, dummysub
!!$TINV  
!!$TINV    do ii=1,allsize
!!$TINV       temp(:,ii)=twoeden03(:,ii)*invscaleweights16(:)  
!!$TINV    enddo
!!$TINV    twoereduced(:,:)=temp(:,:)  !! guess
!!$TINV  
!!$TINV    do ii=1,allsize
!!$TINV       if (orbparflag) then
!!$TINV          call dgsolve0(temp(:,ii),twoereduced(:,ii),numcalled, scaled_operate_sub, 0, &
!!$TINV             dummysub, tinv_tol, totpoints, orblanorder, 1,ierr)
!!$TINV       else
!!$TINV          call dgsolve0(temp(:,ii),twoereduced(:,ii),numcalled, scaled_operate_sub, 0, &
!!$TINV             dummysub, tinv_tol, totpoints, orblanorder, 0,ierr)
!!$TINV       endif
!!$TINV    enddo
!!$TINV  
!!$TINV    call mpibarrier()   !!TEMP?
!!$TINV  
!!$TINV    if (debugflag.ne.0) then
!!$TINV       OFLWR "op_tinv_scaled: iterations=",numcalled; CFL
!!$TINV    endif
!!$TINV  
!!$TINV    call op_tinv_notscaled(twoereduced(:,:),temp(:,:),allsize,circsize,&
!!$TINV         times1,times3,times4,times5,fttimes)
!!$TINV  
!!$TINV    do ii=1,allsize
!!$TINV       twoereduced(:,ii)=temp(:,ii)*invscaleweights16(:)
!!$TINV    enddo
!!$TINV  
!!$TINV  end subroutine op_tinv_scaled
!!$TINV  
!!$TINV  
!!$TINV  !! Op =  1 + (c T-twiddle c - T) T^-1
!!$TINV  
!!$TINV  subroutine scaled_operate_sub(notusedint,in,out)
!!$TINV    use myparams
!!$TINV    use myprojectmod
!!$TINV    implicit none
!!$TINV    integer :: notusedint
!!$TINV    DATATYPE, intent(in) :: in(totpoints)
!!$TINV    DATATYPE, intent(out) :: out(totpoints)
!!$TINV    DATATYPE :: work(totpoints),temp(totpoints),temp2(totpoints)
!!$TINV    integer :: times1,times3,times4,times5,fttimes(10)
!!$TINV    real*8 :: pi=3.141592653589793d0
!!$TINV  
!!$TINV    call op_tinv_notscaled(in(:),temp(:),1,1,&
!!$TINV         times1,times3,times4,times5,fttimes)
!!$TINV  
!!$TINV    work(:)=temp(:)/2d0/pi
!!$TINV  
!!$TINV    temp(:)=work(:)*scaleweights13(:)
!!$TINV    call mult_ke_scaled(temp(:),temp2(:),1,"booga",2)
!!$TINV    out(:)=temp2(:)*scaleweights13(:)
!!$TINV  
!!$TINV    call mult_ke000(work(:),temp(:),1,"booga",2)
!!$TINV  
!!$TINV    out(:) = out(:) + in(:) - temp(:)
!!$TINV  
!!$TINV  end subroutine scaled_operate_sub


  subroutine  op_tinv_notscaled(twoeden03,twoereduced,allsize,circsize,&
       times1,times3,times4,times5,fttimes)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod
    use circ3dsubmod
    use mpisubmod   !! IN PARENT DIRECTORY
    use clockmod      !! IN PARENT DIRECTORY
    implicit none
    integer, intent(in) :: allsize,circsize
    integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
    DATATYPE,intent(in) :: twoeden03(numpoints(1),numpoints(2),numpoints(3),allsize)
    DATATYPE,intent(out) :: twoereduced(totpoints,allsize)
    integer ::   ii, itime,jtime
#ifdef MPIFLAG
    integer ::  ibox1,ibox2,ibox3,jbox1,jbox2,jbox3,jproc,iproc
    DATATYPE,allocatable :: tempden03(:,:,:,:)
#endif
    integer :: circhigh,circbot,circtop,icirc
    DATATYPE,allocatable :: twoeden03huge(:,:,:,:,:,:,:), reducedhuge(:,:,:,:,:,:,:),&
         reducedwork3d(:,:,:,:)

    if (mod(allsize,circsize).ne.0) then
       OFLWR "SIZE ERROR OP_TINV",allsize,circsize; CFLST
    endif

    circhigh=allsize/circsize

#ifdef MPIFLAG
    allocate(tempden03(numpoints(1),numpoints(2),numpoints(3),allsize))
    tempden03(:,:,:,:)=0d0
#endif
    allocate(twoeden03huge(numpoints(1),2,numpoints(2),2,numpoints(3),2,allsize),&
         reducedhuge(numpoints(1),2,numpoints(2),2,numpoints(3),2,allsize),&
         reducedwork3d(numpoints(1),numpoints(2),numpoints(3),allsize))

    twoeden03huge(:,:,:,:,:,:,:)=0d0;  reducedhuge(:,:,:,:,:,:,:)=0; reducedwork3d(:,:,:,:)=0d0;

    twoereduced(:,:)=0d0;  

    do ii=2,griddim
       if (gridpoints(ii).ne.gridpoints(1)) then
          OFLWR "DOME NONCUBE",gridpoints(:); CFLST
       endif
    enddo
#ifdef MPIFLAG
  
    if (orbparflag) then

       call myclock(itime)
       twoeden03huge(:,:,:,:,:,:,:)=0d0; 

       do ibox3=1,nbox(3)  !! processor sending
       do ibox2=1,nbox(2)  !! processor sending
       do ibox1=1,nbox(1)  !! processor sending

          iproc=rankbybox(ibox1,ibox2,ibox3)

          jbox3=(ibox3+1)/2   !! processor receiving
          jbox2=(ibox2+1)/2
          jbox1=(ibox1+1)/2

!!$        jproc=(ibox+1)/2

          jproc=rankbybox(jbox1,jbox2,jbox3)

          if (iproc.eq.myrank.and.jproc.eq.myrank) then
             twoeden03huge(:,mod(ibox1-1,2)+1,:,mod(ibox2-1,2)+1,:,mod(ibox3-1,2)+1,:)=twoeden03(:,:,:,:)
          else if (iproc.eq.myrank) then
             call mympisend(twoeden03,jproc,999,totpoints*allsize)
          else if (jproc.eq.myrank) then
             call mympirecv(tempden03,iproc,999,totpoints*allsize)
             twoeden03huge(:,mod(ibox1-1,2)+1,:,mod(ibox2-1,2)+1,:,mod(ibox3-1,2)+1,:)=tempden03(:,:,:,:)
          endif

       enddo
       enddo
       enddo
       call myclock(jtime); times3=times3+jtime-itime;
    else
#endif
       call myclock(itime)
       twoeden03huge(:,:,:,:,:,:,:)=0d0; 
       twoeden03huge(:,1,:,1,:,1,:)=twoeden03(:,:,:,:)
       call myclock(jtime); times1=times1+jtime-itime;
     
#ifdef MPIFLAG
    endif  !! orbparflag
#endif
  
#ifdef MPIFLAG
    if (orbparflag) then
       call myclock(itime); 
     
       do icirc=1,circhigh
          circbot=(icirc-1)*circsize+1
          circtop=icirc*circsize
#ifdef REALGO
          call circ3d_sub_real_mpi(threed_two(:,:,:),twoeden03huge(:,:,:,:,:,:,circbot:circtop),&
               reducedhuge(:,:,:,:,:,:,circbot:circtop),numpoints(1),numpoints(2),numpoints(3),&
               fttimes,circsize,fft_mpi_inplaceflag)
#else
          call circ3d_sub_mpi(threed_two(:,:,:),twoeden03huge(:,:,:,:,:,:,circbot:circtop),&
               reducedhuge(:,:,:,:,:,:,circbot:circtop),numpoints(1),numpoints(2),numpoints(3),&
               fttimes,circsize,fft_mpi_inplaceflag)
#endif
       enddo
     
       call myclock(jtime); times4=times4+jtime-itime; itime=jtime

       do ibox3=1,nbox(3)  !! processor receiving
       do ibox2=1,nbox(2)
       do ibox1=1,nbox(1)

          iproc=rankbybox(ibox1,ibox2,ibox3)

          jbox3=(ibox3+nbox(3)+1)/2   !! processor sending
          jbox2=(ibox2+nbox(2)+1)/2
          jbox1=(ibox1+nbox(1)+1)/2

!!$         jproc=(ibox+nbox(3)+1)/2

          jproc=rankbybox(jbox1,jbox2,jbox3)

          if (iproc.eq.myrank.and.jproc.eq.myrank) then
             reducedwork3d(:,:,:,:)=reducedhuge(:,mod(ibox1+nbox(1)-1,2)+1,:,mod(ibox2+nbox(2)-1,2)+1,:,mod(ibox3+nbox(3)-1,2)+1,:)
          else if (iproc.eq.myrank) then
             call mympirecv(reducedwork3d(:,:,:,:),jproc,999,totpoints*allsize)
          else if (jproc.eq.myrank) then
             tempden03(:,:,:,:)=reducedhuge(:,mod(ibox1+nbox(1)-1,2)+1,:,mod(ibox2+nbox(2)-1,2)+1,:,mod(ibox3+nbox(3)-1,2)+1,:)
             call mympisend(tempden03(:,:,:,:),iproc,999,totpoints*allsize)
          endif

       enddo
       enddo
       enddo
     
       call myclock(jtime); times5=times5+jtime-itime
    else
#endif
       call myclock(itime)
     
       do icirc=1,circhigh
          circbot=(icirc-1)*circsize+1
          circtop=icirc*circsize
#ifdef REALGO
          call circ3d_sub_real(threed_two(:,:,:),twoeden03huge(:,:,:,:,:,:,circbot:circtop),&
               reducedhuge(:,:,:,:,:,:,circbot:circtop),gridpoints(3),circsize)
#else
          call circ3d_sub(threed_two(:,:,:),twoeden03huge(:,:,:,:,:,:,circbot:circtop),&
               reducedhuge(:,:,:,:,:,:,circbot:circtop),gridpoints(3),circsize)
#endif
       enddo
     
       reducedwork3d(:,:,:,:)=reducedhuge(:,2,:,2,:,2,:)
     
       call myclock(jtime); times4=times4+jtime-itime
#ifdef MPIFLAG
    endif
#endif
     
    twoereduced(:,:) =RESHAPE(reducedwork3d(:,:,:,:),(/totpoints,allsize/))

#ifdef MPIFLAG
    deallocate(tempden03)
#endif
    deallocate(twoeden03huge,       reducedhuge,       reducedwork3d)

    call myclock(jtime); times1=times1+jtime-itime; itime=jtime
  
  end subroutine op_tinv_notscaled

end subroutine op_tinv

end module tinvsubmod


subroutine call_frozen_matels_core(infrozens,numfrozen,frozenkediag,frozenpotdiag,frozenreduced)
  use myparams
  use pmpimod
  use pfileptrmod
  use mycdotmod
  use mpisubmod     !! IN PARENT DIRECTORY
  use orbmultsubmod !! IN PARENT DIRECTORY
  use tinvsubmod
  implicit none
  integer, intent(in) :: numfrozen
  DATATYPE, intent(in) :: infrozens(totpoints,numfrozen)
  DATATYPE, intent(out) :: frozenkediag, frozenpotdiag,frozenreduced(totpoints)
  DATATYPE,allocatable :: frodensity(:,:), tempreduced(:,:), cfrodensity(:,:), &
       tempmult(:,:)
  DATATYPE :: direct(numfrozen,numfrozen),exch(numfrozen,numfrozen),temppotmatel(numfrozen)
  integer :: times1,times3,times4,times5,fttimes(10), i, ii, spf2a,spf2b, &
       ispf,iispf

  if (numfrozen.eq.0) then
     return
  endif

  allocate(frodensity(totpoints,numfrozen), tempreduced(totpoints,numfrozen), &
       cfrodensity(totpoints,numfrozen),   tempmult(totpoints,numfrozen))
  frodensity=0; tempreduced=0; cfrodensity=0; temppotmatel=0; tempmult=0

  do ii=1,numfrozen
     frodensity(:,1)=frodensity(:,1) + infrozens(:,ii)*CONJUGATE(infrozens(:,ii)) * 2
  enddo

  frozenreduced=0
  call op_tinv(frodensity(:,1),frozenreduced(:),1,1,&
       times1,times3,times4,times5,fttimes)

  exch(:,:)=0d0
  do spf2b=1,numfrozen
     do spf2a=1,numfrozen
        frodensity(:,spf2a) = CONJUGATE(infrozens(:,spf2a)) * infrozens(:,spf2b)
     enddo
     cfrodensity(:,:)=CONJUGATE(frodensity(:,:))
     call op_tinv(frodensity(:,:),tempreduced(:,:),numfrozen,numfrozen, &
          times1,times3,times4,times5,fttimes)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(spf2a)
!$OMP DO SCHEDULE(DYNAMIC)
     do spf2a=1,numfrozen
        exch(spf2a,spf2b)=mycdot(cfrodensity(:,spf2a),tempreduced(:,spf2a),totpoints)
     enddo
!$OMP END DO
!$OMP END PARALLEL
  enddo

  do spf2a=1,numfrozen
     frodensity(:,spf2a) = CONJUGATE(infrozens(:,spf2a)) * infrozens(:,spf2a)
  enddo

  call op_tinv(frodensity(:,:),tempreduced(:,:),numfrozen,numfrozen, &
       times1,times3,times4,times5,fttimes)

  direct(:,:)=0d0
  call MYGEMM('T','N',numfrozen,numfrozen,totpoints,DATAONE,frodensity(:,:),totpoints,&
       tempreduced(:,:),totpoints,DATAZERO,direct(:,:),numfrozen)

  if (orbparflag) then
     call mympireduce(direct(:,:),numfrozen**2)
     call mympireduce(exch(:,:),numfrozen**2)
  endif
       
  frozenpotdiag=0d0
  do ispf=1,numfrozen
     do iispf=1,numfrozen
        frozenpotdiag=frozenpotdiag+2*direct(iispf,ispf)-exch(iispf,ispf)
     enddo
  enddo

  call mult_pot(numfrozen,infrozens(:,:),tempmult(:,:))

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(spf2a)
!$OMP DO SCHEDULE(DYNAMIC)
  do spf2a=1,numfrozen
     temppotmatel(spf2a)=mydot(infrozens(:,spf2a),tempmult(:,spf2a),totpoints)
  enddo
!$OMP END DO
!$OMP END PARALLEL

  if (orbparflag) then
     call mympireduce(temppotmatel,numfrozen)
  endif

  do i=1,numfrozen
     frozenpotdiag=frozenpotdiag+2*temppotmatel(i)
  enddo

  call mult_ke(infrozens(:,:),tempmult(:,:),numfrozen,"booga",2)

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(spf2a)
!$OMP DO SCHEDULE(DYNAMIC)
  do spf2a=1,numfrozen
     temppotmatel(spf2a)=mydot(infrozens(:,spf2a),tempmult(:,spf2a),totpoints)
  enddo
!$OMP END DO
!$OMP END PARALLEL

  if (orbparflag) then
     call mympireduce(temppotmatel,numfrozen)
  endif

  frozenkediag=0d0
  do i=1,numfrozen
     frozenkediag=frozenkediag+2*temppotmatel(i)
  enddo

  deallocate(frodensity, tempreduced, cfrodensity, tempmult)

end subroutine call_frozen_matels_core



!! EXCHANGE (direct is op_frozenreduced)

subroutine op_frozen_exchange0(howmany,inspfs,outspfs,infrozens,numfrozen,notusedarr)
  use myparams
  use pmpimod
  use pfileptrmod
  use tinvsubmod
  implicit none
  integer, intent(in) :: numfrozen,howmany,notusedarr(howmany)
  DATATYPE, intent(in) :: infrozens(totpoints,numfrozen), inspfs(totpoints,howmany)
  DATATYPE, intent(out) :: outspfs(totpoints,howmany)
  DATATYPE,allocatable :: frodensity(:,:), tempreduced(:,:)
  integer :: times1,times3,times4,times5,fttimes(10),spf2a,spf2b

  outspfs(:,:)=0d0

  if (numfrozen.eq.0) then
     return
  endif

  allocate(frodensity(totpoints,howmany), tempreduced(totpoints,howmany))
  frodensity=0; tempreduced=0

  do spf2b=1,numfrozen
     do spf2a=1,howmany
        frodensity(:,spf2a) = CONJUGATE(infrozens(:,spf2b)) * inspfs(:,spf2a)
     enddo
     call op_tinv(frodensity(:,:),tempreduced(:,:),howmany,howmany,&
          times1,times3,times4,times5,fttimes)
     do spf2a=1,howmany
        outspfs(:,spf2a) = outspfs(:,spf2a) - tempreduced(:,spf2a)*infrozens(:,spf2b)
     enddo
  enddo

  deallocate(frodensity, tempreduced)

end subroutine op_frozen_exchange0


subroutine getdensity() !density, indenmat, inspfs,howmany)
print *, "DOME GETDENSITY"; stop
end subroutine getdensity


subroutine op_conjg(in,out)
  use myparams
  use pmpimod
  implicit none
  DATATYPE,intent(in) :: in(totpoints)
  DATATYPE,intent(out) :: out(totpoints)
  out(:)=ALLCON(in(:))
end subroutine op_conjg

subroutine op_reflectz(in,out)
  use myparams
  use pmpimod
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  DATATYPE,intent(in) :: in(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE,intent(out) :: out(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE,allocatable :: work(:,:,:)
  integer :: partrank(3),partner,i

  allocate(work(numpoints(1),numpoints(2),numpoints(3)))
  work=0

  if (orbparflag) then
     partrank(:)=boxrank(:)
     partrank(3) = nbox(3) + 1 - boxrank(3)
     partner = rankbybox(partrank(1),partrank(2),partrank(3))
     if (partner.eq.myrank) then
        work(:,:,:)=in(:,:,:)
     else
        call mympisendrecv(in,work,partner,partner,0,totpoints)
     endif
  else
     work(:,:,:)=in(:,:,:)
  endif

  do i=1,numpoints(3)
     out(:,:,numpoints(3)+1-i)=work(:,:,i)
  enddo

  deallocate(work)

end subroutine op_reflectz


subroutine op_reflecty(in,out)
  use myparams
  use pmpimod
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  DATATYPE,intent(in) :: in(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE,intent(out) :: out(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE,allocatable :: work(:,:,:)
  integer :: partrank(3),partner,i

  allocate(work(numpoints(1),numpoints(2),numpoints(3)))
  work=0

  if (orbparflag) then
     partrank(:)=boxrank(:)
     partrank(2) = nbox(2) + 1 - boxrank(2)
     partner = rankbybox(partrank(1),partrank(2),partrank(3))
     if (partner.eq.myrank) then
        work(:,:,:)=in(:,:,:)
     else
        call mympisendrecv(in,work,partner,partner,0,totpoints)
     endif
  else
     work(:,:,:)=in(:,:,:)
  endif

  do i=1,numpoints(2)
     out(:,numpoints(2)+1-i,:)=work(:,i,:)
  enddo

  deallocate(work)

end subroutine op_reflecty


subroutine op_reflectx(in,out)
  use myparams
  use pmpimod
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  DATATYPE,intent(in) :: in(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE,intent(out) :: out(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE,allocatable :: work(:,:,:)
  integer :: partrank(3),partner,i

  allocate(work(numpoints(1),numpoints(2),numpoints(3)))
  work=0

  if (orbparflag) then
     partrank(:)=boxrank(:)
     partrank(1) = nbox(1) + 1 - boxrank(1)
     partner = rankbybox(partrank(1),partrank(2),partrank(3))
     if (partner.eq.myrank) then
        work(:,:,:)=in(:,:,:)
     else
        call mympisendrecv(in,work,partner,partner,0,totpoints)
     endif
  else
     work(:,:,:)=in(:,:,:)
  endif

  do i=1,numpoints(1)
     out(numpoints(1)+1-i,:,:)=work(i,:,:)
  enddo

  deallocate(work)

end subroutine op_reflectx



subroutine mult_zdipole(howmany,in,out,realflag)
  use myparams
  use myprojectmod
  implicit none
  integer,intent(in) :: realflag,howmany
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE,intent(out) :: out(totpoints,howmany)
  integer :: ii
  do ii=1,howmany
#ifndef CNORMFLAG
  if (realflag.ne.0) then
     out(:,ii)=in(:,ii)*real(dipoles(:,3),8)
  else
#endif
  out(:,ii)=in(:,ii)*dipoles(:,3)
#ifndef CNORMFLAG
  endif
#endif
  enddo
end subroutine mult_zdipole


subroutine mult_ydipole(howmany,in,out,realflag)
  use myparams
  use myprojectmod
  implicit none
  integer,intent(in) :: realflag,howmany
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE,intent(out) :: out(totpoints,howmany)
  integer :: ii
  do ii=1,howmany
#ifndef CNORMFLAG
  if (realflag.ne.0) then
     out(:,ii)=in(:,ii)*real(dipoles(:,2),8)
  else
#endif
  out(:,ii)=in(:,ii)*dipoles(:,2)
#ifndef CNORMFLAG
  endif
#endif
  enddo
end subroutine mult_ydipole


subroutine mult_xdipole(howmany,in,out,realflag)
  use myparams
  use myprojectmod
  implicit none
  integer,intent(in) :: realflag,howmany
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE,intent(out) :: out(totpoints,howmany)
  integer :: ii
  do ii=1,howmany
#ifndef CNORMFLAG
  if (realflag.ne.0) then
     out(:,ii)=in(:,ii)*real(dipoles(:,1),8)
  else
#endif
  out(:,ii)=in(:,ii)*dipoles(:,1)
#ifndef CNORMFLAG
  endif
#endif
  enddo

end subroutine mult_xdipole



!! DIRECT (exchange is op_frozen_exchange)

subroutine op_frozenreduced(howmany,inspfs,outspfs,frozenreduced)
  use myparams
  use pmpimod
  use pfileptrmod
  implicit none
  integer,intent(in) :: howmany
  DATATYPE,intent(in) :: inspfs(totpoints,howmany),frozenreduced(totpoints)
  DATATYPE,intent(out) :: outspfs(totpoints,howmany)
  integer :: ii

  do ii=1,howmany
     outspfs(:,ii) = frozenreduced(:) * inspfs(:,ii)
  enddo

end subroutine op_frozenreduced


subroutine restrict_spfs() !inspfs,howmany,spfmvals)
end subroutine restrict_spfs

subroutine ugrestrict_spfs() !inspfs,howmany,spfmvals)
end subroutine ugrestrict_spfs

subroutine restrict_spfs0() !inspfs,howmany,spfmvals,printflag)
end subroutine restrict_spfs0

subroutine ugrestrict_spfs0() !inspfs,howmany,spfmvals,printflag)
end subroutine ugrestrict_spfs0

subroutine bothcompact_spfs() !inspfs,outspfs,howmany,spfmvals,spfugvals)
use pfileptrmod
implicit none
OFLWR "NOT APPLICABLE BOTHCOMPACT SINCDVR"; CFLST
end subroutine bothcompact_spfs

subroutine bothexpand_spfs() !inspfs,outspfs,howmany,spfmvals,spfugvals)
use pfileptrmod
implicit none
OFLWR "NOT APPLICABLE BOTHEXPAND SINCDVR"; CFLST
end subroutine bothexpand_spfs

subroutine mcompact_spfs() !inspfs,outspfs,howmany,spfmvals)
use pfileptrmod
implicit none
OFLWR "NOT APPLICABLE MCOMPACT SINCDVR"; CFLST
end subroutine mcompact_spfs

subroutine mexpand_spfs() !inspfs,outspfs,howmany,spfmvals)
use pfileptrmod
implicit none
OFLWR "NOT APPLICABLE MEXPAND SINCDVR"; CFLST
end subroutine mexpand_spfs



subroutine call_twoe_matel00(lowspf,highspf,inspfs10,inspfs20,twoematel,twoereduced,timingdir,notiming) 
  use myparams
  use pfileptrmod
  use myprojectmod
  use clockmod      !! IN PARENT DIRECTORY
  implicit none
  integer, intent(in) :: notiming,lowspf,highspf
  DATATYPE,intent(in) :: inspfs10(totpoints,numspf),inspfs20(totpoints,numspf)
  DATATYPE,intent(out) :: twoematel(numspf,numspf,numspf,lowspf:highspf),&
       twoereduced(totpoints,numspf,lowspf:highspf)
  character,intent(in) :: timingdir*(*)
  integer :: nnnspf

  if (fft_batchdim.lt.1.or.fft_batchdim.gt.2) then
     OFLWR "fft_batchdim error", fft_batchdim; CFLST
  endif
  if (fft_circbatchdim.gt.fft_batchdim) then
     OFLWR "Error, fft_circbatchdim can't be greater than fft_batchdim",fft_circbatchdim,fft_batchdim; CFLST
  endif
  if (fft_circbatchdim.lt.0.or.fft_circbatchdim.gt.2) then
     OFLWR "circbatchdim error", fft_circbatchdim; CFLST
  endif

  nnnspf=highspf-lowspf+1
  if (nnnspf.gt.0) then
     call call_twoe_matelxxx00(lowspf,highspf,inspfs10,inspfs20,twoematel,twoereduced,timingdir,notiming) 
  endif

contains

  subroutine call_twoe_matelxxx00(lowspf,highspf,inspfs10,inspfs20,twoematel,twoereduced,timingdir,notiming) 
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod
    use tinvsubmod
    implicit none
    integer, intent(in) :: lowspf,highspf,notiming
    DATATYPE,intent(in) :: inspfs10(totpoints,numspf),inspfs20(totpoints,numspf)
    DATATYPE,intent(out) :: twoematel(numspf,numspf,numspf,lowspf:highspf),&
         twoereduced(totpoints,numspf,lowspf:highspf)
    character,intent(in) :: timingdir*(*)
    integer ::  spf1a, spf1b, spf2a, spf2b, itime,jtime,getlen,&
         spf2low,spf2high,index2b,index2low,index2high, firsttime,lasttime,nnnspf,qq,myiostat
    integer, save :: xcount=0, times(10)=0,fttimes(10)=0,qqcount=0
    DATATYPE, allocatable :: twoeden03(:,:) 
    DATATYPE :: twoemattemp(numspf,numspf),  myden(totpoints)

    nnnspf=highspf-lowspf+1

    if (highspf.gt.numspf.or.lowspf.lt.1) then
       OFLWR "programmer fail!!! YYY",lowspf,highspf,numspf; CFLST
    endif

    times(:)=0; fttimes(:)=0;   !! ZEROING TIMES... not cumulative

    call myclock(firsttime); itime=firsttime

    if ((myrank.eq.1).and.(notiming.eq.0)) then
       if (debugflag.eq.10) then
          open(8853, file=timingdir(1:getlen(timingdir))//"/twoematel.abs.time.dat", &
               status="unknown", position="append",iostat=myiostat)
          call checkiostat(myiostat,"opening twoematel timing sincdvr")
          write(8853,*,iostat=myiostat) "****"
          call checkiostat(myiostat,"writing twoematel timing sincdvr")
          close(8853)
          call system("date --rfc-3339=ns >>"//timingdir(1:getlen(timingdir))//"/twoematel.abs.time.dat")
       endif
    endif

    if (griddim.ne.3) then
       OFLWR "OOGA DIM"; CFLST
    endif

    twoereduced(:,:,:)=0d0;   twoematel(:,:,:,:)=0

    if (notwoflag.ne.0) then
       return
    endif

!!$  allocate(twoeden03(numpoints(1),numpoints(2),numpoints(3),numspf**fft_batchdim))

    allocate(twoeden03(totpoints,batchindex(1,lowspf):batchindex(numspf,highspf)))
    twoeden03(:,:)=0

    call myclock(jtime); times(1)=times(1)+jtime-itime;  
  
    select case(fft_batchdim)
    case(1)
       index2low=lowspf; index2high=highspf
    case(2)
       index2low=1; index2high=1
    case default
       OFLWR "ACK BACTCHDIM", fft_batchdim; CFLST
       index2low=999; index2high=(-42)    !! avoid warn unused
    end select
  
    do index2b=index2low,index2high

       select case(fft_batchdim)
       case(1)
          spf2low=index2b;        spf2high=index2b
       case(2)
          spf2low=lowspf; spf2high=highspf
       case default
          OFLWR "ACK BACTCHDIM", fft_batchdim; CFLST
          spf2low=42; spf2high=(-999)   !! avoid warn unused
       end select

 ! integrating over electron 2

       call myclock(itime)
       do spf2b=spf2low,spf2high
          do spf2a=1,numspf

             twoeden03(:,batchindex(spf2a,spf2b))=&

!! switching 2-2016     CONJUGATE(inspfs10(:,spf2a)) * inspfs20(:,spf2b)
                  inspfs10(:,spf2a) * CONJUGATE(inspfs20(:,spf2b))
          enddo
       enddo
       call myclock(jtime); times(2)=times(2)+jtime-itime;

       select case(fft_circbatchdim)
       case(0)
          qq=1
       case(1)
          qq=numspf
       case(2)
          qq=nnnspf*numspf
       case default
          OFLWR "AUUGUGUGH circbatchdim not allowed",fft_circbatchdim; CFLST
       end select
       call op_tinv(twoeden03(:,batchindex(1,spf2low)), twoereduced(:,1,spf2low),&
            nnnspf**(fft_batchdim-1)*numspf, qq, times(1),times(3),times(4),times(5),fttimes)

    enddo  !! DO INDEX2B

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! MPI reduction is performed in main MCTDHF routines NOT HERE !!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    twoemattemp(:,:)=0

    if (nnnspf.gt.0) then
       do spf1b=1,numspf
          do spf1a=1,numspf
             
!! switching 2-2016       myden(:)=CONJUGATE(inspfs10(:,spf1a)) * inspfs20(:,spf1b)
             myden(:)=inspfs10(:,spf1a) * CONJUGATE(inspfs20(:,spf1b))
             call MYGEMV('T',totpoints,numspf*nnnspf,DATAONE,twoereduced(:,:,lowspf:highspf),totpoints,myden,1,&
                  DATAZERO,twoemattemp(:,lowspf:highspf),1)
             twoematel(spf1a,spf1b,:,lowspf:highspf)=twoemattemp(:,lowspf:highspf)
          enddo
       enddo
    endif
    deallocate(twoeden03)

    call myclock(jtime); times(6)=times(6)+jtime-itime;  
    lasttime=jtime
    times(7)=times(7)+lasttime-firsttime

!!$  if (getpot.ne.0) then
!!$     jj=numspf**2;     ii=totpoints
!!$     call MYGEMM('N','N', ii,jj,jj,DATAONE, twoereduced(:,:,:),ii,twoden(:,:,:,:),jj, DATAONE,reducedpot(:,:,:),ii)
!!$  endif

    xcount=xcount+1

    if ((myrank.eq.1).and.(notiming.eq.0)) then
       if (xcount==1) then
          open(853, file=timingdir(1:getlen(timingdir))//"/twoematel.time.dat", &
               status="unknown",iostat=myiostat)
          call checkiostat(myiostat,"opening twoematel timing sincdvr")
#ifdef MPIFLAG
          if (orbparflag) then
             if (fft_mpi_inplaceflag==1) then
                write(853,'(100A11)')   "etc", "1den", "1mpi", "F.T.", "2mpi", "dot","ALL",   &
                     "ft_copy",  "ft_conjg", "ft_ft1d","ft_tr","ft_mpi","ft_copy","ft_circ"
             else
                write(853,'(100A11)')   "etc", "1den", "1mpi", "F.T.", "2mpi", "dot","ALL",   &
                     "ft_conjg","ft_twid","ft_mpict","ft_raise","ft_tmult","ft_ft3d", "ft_circ"
             endif
          else
#endif
             write(853,'(100A11)')   "etc", "1den", "1mpi", "F.T.", "2mpi", "dot","ALL"
#ifdef MPIFLAG
          endif
#endif
          close(853)
       endif
       open(853, file=timingdir(1:getlen(timingdir))//"/twoematel.time.dat", &
            status="unknown", position="append",iostat=myiostat)
       call checkiostat(myiostat,"opening twoematel timing sincdvr")
       write(853,'(100I11)',iostat=myiostat)  times(1:7),fttimes(1:7);
       call checkiostat(myiostat,"writing twoematel timing sincdvr")
       close(853)
    endif

!!! from circ subs, fttimes
!!!
!!! fttimes(7) = circ multiply

!!! from myzfft3d_par (if fft_mpi_inplaceopt == 1):

!!! fttimes(1) = copy  fttimes(2) = conjg  fttimes(3) = ft
!!! from mytranspose fttimes(4) = transpose   fttimes(5) = mpi  fttimes(6) = copy

!!! from cooleytukey (if fft_mpi_inplaceopt == 0):

!!! fttimes(1) conjugate
!!! fttimes(2) gettwiddle
!!! fttimes(3) 1d ft-slowindex
!!! fttimes(4) raise twiddle factor to power
!!! fttimes(5) multiply
!!! fttimes(6) 3d f.t.


    if (myrank.eq.1.and.(notiming.eq.0).and.debugflag.eq.10) then
       call system("date --rfc-3339=ns >>"//timingdir(1:getlen(timingdir))//"/twoematel.abs.time.dat")
       open(8853, file=timingdir(1:getlen(timingdir))//"/twoematel.abs.time.dat", &
            status="unknown", position="append",iostat=myiostat)
       call checkiostat(myiostat,"opening twoematel timing sincdvr")
       write(8853,*,iostat=myiostat) "****"
       call checkiostat(myiostat,"writing twoematel timing sincdvr")
       close(8853)
    endif

    qqcount=qqcount+1
    if ((notiming.eq.0).and.debugflag.eq.10.and.qqcount.gt.1) then
       OFLWR "DEBUG10STOP"; CFLST
    endif

  end subroutine call_twoe_matelxxx00

  function batchindex(spf2a,spf2b)
    implicit none
    integer :: spf2a,spf2b,batchindex
    select case(fft_batchdim)
    case(1)
       batchindex=spf2a
    case(2)
       batchindex=spf2a+(spf2b-1)*numspf
    case default
       OFLWR "ACK BATCHINDEX FUNCTION",spf2a,spf2b; CFLST
       batchindex=999
    end select
  end function batchindex

end subroutine call_twoe_matel00



!! OUTPUTS orbitals from firstspf to lastspf (out of numspf)

subroutine mult_reducedpot(firstspf,lastspf,inspfs,outspfs,reducedpot)
  use myparams
  implicit none
  integer,intent(in) :: firstspf,lastspf
  DATATYPE,intent(out) :: outspfs(totpoints,firstspf:lastspf)
  DATATYPE,intent(in) :: inspfs(totpoints, numspf),reducedpot(totpoints, numspf,firstspf:lastspf)
  DATATYPE :: myspf(totpoints)         !! AUTOMATIC
  integer :: ispf,kspf

  outspfs(:,:)=0d0

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ispf,kspf,myspf)
!$OMP DO SCHEDULE(DYNAMIC)
  do ispf=firstspf,lastspf
     myspf(:)=0d0
     do kspf=1,numspf

!!$ CLASSES?
!!$        if (she lls(kspf).eq.ish ell) then
!!$ reducedpot is usual notation: <ispf | kspf> so so sum over slow index kspf
                    
        myspf(:) = myspf(:) + &

!!$ switching 2-2016             reducedpot(:,ispf,kspf) * inspfs(:,kspf)

             reducedpot(:,kspf,ispf) * inspfs(:,kspf)

!!$        endif

     enddo
     outspfs(:,ispf)=myspf(:)
  enddo
!$OMP END DO
!$OMP END PARALLEL

end subroutine mult_reducedpot


module multgenmod
contains

!! option=1 ke   option=2 first deriv

subroutine mult_general(option,xcoef,ycoef,zcoef,in,out,howmany,timingdir,notiming)
  use myparams
  use myprojectmod
  use pmpimod
  use pfileptrmod
  use mpisubmod    !! IN PARENT DIRECTORY
  use clockmod      !! IN PARENT DIRECTORY
  implicit none
  integer, intent(in) :: option,howmany,notiming
  character,intent(in) :: timingdir*(*)
  DATATYPE, intent(in) :: in(totpoints,howmany), xcoef, ycoef, zcoef
  DATATYPE, intent(out) :: out(totpoints,howmany)

#ifdef MPIFLAG
  if (orbparflag.and.transmultflag) then
     if (orbparlevel.eq.1) then
        OFLWR "ERROR, transmultflag=.true. not possible with orbparlevel=1"; CFLST
     endif
     call mult_general_withtranspose(option,xcoef,ycoef,zcoef,in,out,howmany,timingdir,notiming)
  else
#endif

     call mult_general_withbcast(option,xcoef,ycoef,zcoef,in,out,howmany,timingdir,notiming)

#ifdef MPIFLAG
  endif
#endif

contains

  subroutine divide_mask(in,out,howmany)
    use myparams
    use myprojectmod
    implicit none
    integer,intent(in) :: howmany
    DATATYPE,intent(in) :: in(numpoints(1),numpoints(2),numpoints(3),howmany)
    DATATYPE, intent(out) :: out(numpoints(1),numpoints(2),numpoints(3),howmany)
    DATATYPE :: work(numpoints(1),numpoints(2),numpoints(3),howmany)        !! AUTOMATIC
    integer :: ii

    work=0

    do ii=1,numpoints(1)
       out(ii,:,:,:)=in(ii,:,:,:)/maskfunction(1)%rmat(ii)
    enddo
    do ii=1,numpoints(2)
       work(:,ii,:,:)=out(:,ii,:,:)/maskfunction(2)%rmat(ii)
    enddo
    do ii=1,numpoints(3)
       out(:,:,ii,:)=work(:,:,ii,:)/maskfunction(3)%rmat(ii)
    enddo
 
  end subroutine divide_mask

  subroutine mult_mask(in,out,howmany)
    use myparams
    use myprojectmod
    implicit none
    integer,intent(in) :: howmany
    DATATYPE,intent(in) :: in(numpoints(1),numpoints(2),numpoints(3),howmany)
    DATATYPE, intent(out) :: out(numpoints(1),numpoints(2),numpoints(3),howmany)
    DATATYPE :: work(numpoints(1),numpoints(2),numpoints(3),howmany)     !! AUTOMATIC
    integer :: ii

    work=0

    do ii=1,numpoints(1)
       out(ii,:,:,:)=in(ii,:,:,:)*maskfunction(1)%rmat(ii)
    enddo
    do ii=1,numpoints(2)
       work(:,ii,:,:)=out(:,ii,:,:)*maskfunction(2)%rmat(ii)
    enddo
    do ii=1,numpoints(3)
       out(:,:,ii,:)=work(:,:,ii,:)*maskfunction(3)%rmat(ii)
    enddo
 
  end subroutine mult_mask

  subroutine mult_general_withbcast(option,xcoef,ycoef,zcoef,in,out,howmany,timingdir,notiming)
    use myparams
    use myprojectmod
    implicit none
    integer, intent(in) :: option,howmany,notiming
    integer :: ii,jj
    character,intent(in) :: timingdir*(*)
    DATATYPE, intent(in) :: in(totpoints,howmany), xcoef, ycoef, zcoef
    DATATYPE, intent(out) :: out(totpoints,howmany)
    DATATYPE :: temp(totpoints,howmany),temp2(totpoints,howmany)   !!AUTOMATIC
    DATATYPE :: mycoefs(3)

    temp(:,:)=0;  temp2(:,:)=0;  out(:,:)=0d0

    if (option.eq.2) then 
       mycoefs(:) = (/ xcoef,ycoef,zcoef /)
    else
       mycoefs(:) = (/ 1d0, 1d0, 1d0 /)
    endif

    do jj=1,3

       if (abs(mycoefs(jj)).gt.0d0) then

          if (scalingflag.ne.0) then
             if (option.eq.1) then        !! KE
                do ii=1,howmany
                   temp(:,ii)=in(:,ii)*invjacobian(:,jj)
                enddo
             else                         !! FIRST DER
                do ii=1,howmany
                   temp(:,ii)=in(:,ii)*invsqrtjacobian(:,jj)
                enddo
             endif
          else if (maskflag.ne.0) then
             call divide_mask(in,temp,howmany)
          else
             temp(:,:)=in(:,:)
          endif

          call mult_allpar(option,jj,temp(:,:), temp2(:,:),howmany,timingdir,notiming)

          if (scalingflag.ne.0) then
             if (option.eq.1) then        !! KE
                do ii=1,howmany
                   out(:,ii)=out(:,ii)+temp2(:,ii)*invjacobian(:,jj)   * mycoefs(jj)
                enddo
             else                         !! FIRST DER
                do ii=1,howmany
                   out(:,ii)=out(:,ii)+temp2(:,ii)*invsqrtjacobian(:,jj)   * mycoefs(jj)
                enddo
             endif
          else if (maskflag.ne.0) then
             call mult_mask(temp2,temp,howmany)
             out(:,:)=out(:,:)+temp(:,:)   * mycoefs(jj)
          else
             out(:,:)=out(:,:)+temp2(:,:)   * mycoefs(jj)
          endif
       endif
    enddo

    if (option.eq.1) then
       if (scalingflag.ne.0) then
          do ii=1,howmany
             out(:,ii)=out(:,ii) + in(:,ii) * scalediag(:) 
          enddo
       endif
    endif

  end subroutine mult_general_withbcast

#ifdef MPIFLAG

!! ASSUMES CUBE (EVERYTHING THE SAME X,Y,Z)
!! ASSUMES CUBE (EVERYTHING THE SAME X,Y,Z)
!! ASSUMES CUBE (EVERYTHING THE SAME X,Y,Z)

  subroutine mult_general_withtranspose(option,xcoef,ycoef,zcoef,in,out,howmany,timingdir,notiming)
    use myparams
    use myprojectmod
    use pmpimod
    use pfileptrmod
    implicit none
    integer, intent(in) :: option,howmany,notiming
    character,intent(in) :: timingdir*(*)
    DATATYPE, intent(in) :: in(totpoints,howmany), xcoef, ycoef, zcoef
    DATATYPE, intent(out) :: out(totpoints,howmany)
    DATATYPE :: temp(totpoints,howmany),temp2(totpoints,howmany),inwork(totpoints,howmany)   !!AUTOMATIC
    DATATYPE :: mycoefs(3)
    integer :: ii,jj,atime,btime,myiostat,getlen
    integer, save :: xcount=0, times(0:10)=0

    call myclock(atime)

    out(:,:)=0d0; temp=0; temp2=0;
    inwork(:,:)=in(:,:)

    if (.not.orbparflag) then
       OFLWR "ACK DONT CALLME MULT_GENERAL_WITHtRANSPOSE ORBPARFLAG FALSE"; CFLST
    endif

    if (option.eq.2) then 
       mycoefs(:) = (/ xcoef,ycoef,zcoef /)
    else
       mycoefs(:) = (/ 1d0, 1d0, 1d0 /)
    endif

    do jj=1,3

       if (abs(mycoefs(jj)).gt.0d0) then

          if (scalingflag.ne.0) then
             if (option.eq.1) then        !! KE
                do ii=1,howmany
                   temp(:,ii)=inwork(:,ii)*invjacobian(:,1)
                enddo
             else                         !! FIRST DER
                do ii=1,howmany
                   temp(:,ii)=inwork(:,ii)*invsqrtjacobian(:,1)
                enddo
             endif
          else if (maskflag.ne.0) then
             call divide_mask(inwork,temp,howmany)
          else
             temp(:,:)=inwork(:,:)
          endif

          call mult_allpar(option,1,temp(:,:), temp2(:,:),howmany,timingdir,notiming)

          if (scalingflag.ne.0) then
             if (option.eq.1) then        !! KE
                do ii=1,howmany
                   out(:,ii)=out(:,ii)+temp2(:,ii)*invjacobian(:,1)   * mycoefs(jj)
                enddo
             else                         !! FIRST DER
                do ii=1,howmany
                   out(:,ii)=out(:,ii)+temp2(:,ii)*invsqrtjacobian(:,1)   * mycoefs(jj)
                enddo
             endif
          else if (maskflag.ne.0) then
             call mult_mask(temp2,temp,howmany)
             out(:,:)=out(:,:)+temp(:,:)   * mycoefs(jj)
          else
             out(:,:)=out(:,:)+temp2(:,:)   * mycoefs(jj)
          endif

       endif

       call myclock(btime); times(0)=times(0)+btime-atime; atime=btime

!! TRANSPOSE
       select case(orbparlevel)
       case(3)
          call mytranspose(out,temp,numpoints(3),howmany,times(1:),nprocs,nprocs)
          out(:,:)=temp(:,:)
          call mytranspose(inwork,temp,numpoints(3),howmany,times(1:),nprocs,nprocs)
          inwork(:,:)=temp(:,:)
       case(2)
          call mytranspose(out,temp,numpoints(3),howmany,times(1:),sqnprocs,1)
          out(:,:)=temp(:,:)
          call mytranspose(inwork,temp,numpoints(3),howmany,times(1:),sqnprocs,1)
          inwork(:,:)=temp(:,:)
       case default
          OFLWR "NOT SUPPP WITH THRANSPOSE ORBPARLEVEL=",orbparlevel; CFLST
       end select

       call myclock(atime)

    enddo

    if (option.eq.1) then
       if (scalingflag.ne.0) then
          do ii=1,howmany
             out(:,ii)=out(:,ii) + in(:,ii) * scalediag(:) 
          enddo
       endif
    endif

    if (myrank.eq.1.and.notiming.lt.2) then
       xcount=xcount+1
       if (xcount==1) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke.time.dat", &
               status="unknown",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100A11)',iostat=myiostat)   "mult", "before","mpi", "after"
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853) 
       endif
       if (mod(xcount,100).eq.0) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke.time.dat", &
               status="unknown", position="append",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100I11)',iostat=myiostat)  times(0:3)
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853)
       endif
    endif


  end subroutine mult_general_withtranspose

  subroutine mytranspose(in,out,blocksize,howmany,times,nprocs1,nprocs2)
    use pmpimod  !! box_comm
    implicit none
    integer,intent(in) :: blocksize,howmany,nprocs1,nprocs2
    integer,intent(inout) :: times(3)
    DATATYPE,intent(in) :: in(nprocs1*blocksize,nprocs2*blocksize,blocksize,howmany)
    DATATYPE,intent(out) :: out(nprocs1*blocksize,nprocs2*blocksize,blocksize,howmany)
    integer :: atime,btime,i,count,ii,iproc,j
    DATATYPE :: intranspose(nprocs2*blocksize,blocksize,blocksize,howmany,nprocs1)  !!AUTOMATIC
    DATATYPE :: outtemp(nprocs2*blocksize,blocksize,blocksize,howmany,nprocs1)      !!AUTOMATIC
    DATATYPE :: outone(nprocs2*blocksize,blocksize,blocksize,nprocs1)       !!AUTOMATIC OpenMP
    DATATYPE :: inchop(blocksize,nprocs2*blocksize,blocksize,howmany)       !!AUTOMATIC OpenMP


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!    (123)->(231)    !!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
    call myclock(atime)

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(iproc,ii,i,inchop)

    do iproc=1,nprocs1

       inchop(:,:,:,:)=in((iproc-1)*blocksize+1:iproc*blocksize,:,:,:)

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
       do ii=1,howmany
          do i=1,blocksize

!! (123)->(231)  (:,:,7) -> (:,7,:)
!! (123)->(231)  (:,5,7) -> (5,7,:)

             intranspose(:,:,i,ii,iproc)=inchop(i,:,:,ii)

          enddo
       enddo
!$OMP END DO
    enddo

!$OMP END PARALLEL

    call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

    outtemp(:,:,:,:,:)=0d0
  
    count=blocksize**3 * nprocs2 * howmany

    if (nprocs1.eq.nprocs2) then  !! orbparlevel=3

!! 231  (:,7,:) -> (:,:,7)

       call mympialltoall(intranspose,outtemp,count)

    else

!! 231  (5,7,:) -> (7,5,:)

       call mympisendrecv(intranspose,outtemp,&
            rankbybox(boxrank(1),boxrank(3),boxrank(2)), rankbybox(boxrank(1),boxrank(3),boxrank(2)), &
            999,count*nprocs1)

       intranspose(:,:,:,:,:)=outtemp(:,:,:,:,:)

!! 231  (7,5,:) -> (:,5,7)

       call mympialltoall_local(intranspose,outtemp,count,BOX_COMM(1,boxrank(2),3))

    endif

    call myclock(btime); times(2)=times(2)+btime-atime; atime=btime

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii,i,j,outone)
    do ii=1,howmany

       outone(:,:,:,:)=outtemp(:,:,:,ii,:)

       if (nprocs1.eq.nprocs2) then

!! (231) collecting middle index, 3.. have first index,2

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
          do i=1,blocksize
             do j=1,nprocs1*blocksize
                out(j,:,i,ii)=RESHAPE(outone(j,:,i,:),(/nprocs1*blocksize/))
             enddo
          enddo
!$OMP END DO
       else

!! (231) collecting first index,2

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
          do i=1,blocksize
             do j=1,blocksize
                out(:,j,i,ii)=RESHAPE(outone(:,j,i,:),(/nprocs1*blocksize/))
             enddo
          enddo
!$OMP END DO
        
       endif
    enddo
!$OMP END PARALLEL

    call myclock(btime); times(3)=times(3)+btime-atime;

  end subroutine mytranspose

#endif

!! option=1 ke    option=2 first derivative

  subroutine mult_allpar(option,idim, in, out,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    implicit none
    integer,intent(in) :: idim,option,howmany,notiming
    DATATYPE,intent(in) :: in(totpoints,howmany)
    DATATYPE, intent(out) :: out(totpoints,howmany)
    character,intent(in) :: timingdir*(*)

    if (griddim.ne.3) then
       OFLWR "ERWRESTOPPP"; CFLST
    endif
    if (option.ne.1.and.option.ne.2) then
       OFLWR "OWWOWORE WHAT?", option; CFLST
    endif

    if (.not.orbparflag.or.idim.lt.orbparlevel) then
       call mult_allone(in,out,idim,option,howmany)
    else
       select case(zke_paropt)
       case(0)
          call mult_circ_gen(idim,in,out,option,howmany,timingdir,notiming)
       case(1)
          call mult_summa_gen(idim,in,out,option,howmany,timingdir,notiming)
       case(2)
          call mult_gather_gen(idim,in,out,option,howmany,timingdir,notiming)
       case default
          OFLWR "Error, zke_paropt not recognized",zke_paropt; CFLST
       end select
    endif

  end subroutine mult_allpar

!!  RATE LIMITING STEP IN CODE: MPI PARALLEL KINETIC ENERGY MULTIPLICATION!!
!!  THREE OPTIONS
!!
!!  zke_paropt=0   mult_circ   sendrecv
!!  zke_paropt=1   mult_summa  SUMMA  scalable universal matrix multiplication algorithm (broadcast before)
!!  zke_paropt=2   mult_gather gather and multiply locally in blocks


  subroutine mult_gather_gen(indim,in, out,option,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: option,howmany,indim,notiming
    DATATYPE,intent(in) :: in(totpoints,howmany)
    DATATYPE,intent(out) :: out(totpoints,howmany)
    character,intent(in) :: timingdir*(*)
    integer :: nnn,mmm,ii
    nnn=1
    do ii=1,indim-1
       nnn=nnn*numpoints(ii)
    enddo
    mmm=howmany
    do ii=indim+1,3
       mmm=mmm*numpoints(ii)
    enddo
    call mult_gather_gen0(nnn,indim,in,out,option,mmm,timingdir,notiming)
  end subroutine mult_gather_gen

  subroutine mult_gather_gen0(nnn,indim,in, out,option,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: nnn,option,howmany,indim,notiming
    DATATYPE,intent(in) :: in(nnn*numpoints(indim),howmany)
    DATATYPE,intent(out) :: out(nnn*numpoints(indim),howmany)
    character,intent(in) :: timingdir*(*)
    DATATYPE,allocatable ::  work(:,:,:),work2(:,:,:)
    integer :: atime,btime,getlen,myiostat,batchsize,iproc,&
         ibatch,procs,numbatch,batchlow,batchhigh,rank,comm,totsize,&
         blocksizes(procsplit(indim)),thisbatchsize
    integer, save :: xcount=0, times(10)=0

    procs=procsplit(indim)

!!    batchsize=(howmany-1)/procs+1
!!    numbatch=(howmany-1)/batchsize+1

!!    batchsize=howmany
!!    numbatch=1

    batchsize=1
    numbatch=howmany

    if (procs.le.1) then
       OFLWR "procsplit error gather", procsplit(indim),indim; CFLST
    endif
    if (procs*numpoints(indim).ne.gridpoints(indim)) then
       print *, "KE GATHER ERROR", procs,numpoints(indim),gridpoints(indim),indim; stop
    endif

    call myclock(atime)

    allocate(work(nnn*numpoints(indim),batchsize,nprocs), &
         work2(nnn*numpoints(indim),procs,batchsize))

    out(:,:)=0; work=0; work2=0

    select case (indim)
    case(3)
       rank=boxrank(3)
       comm=BOX_COMM(boxrank(1),boxrank(2),3)
    case(2)
       rank=boxrank(2)
       select case(orbparlevel)
       case(2)
          comm=BOX_COMM(boxrank(1),boxrank(3),2)
       case(1)
          comm=BOX_COMM(boxrank(3),boxrank(1),2)
       case default
          print *, "ACK LEVEL"; stop
       end select
    case(1)
       rank=boxrank(1)
       comm=BOX_COMM(boxrank(2),boxrank(3),1)
    case default 
       print *, "ACK dim"; stop
    end select

    call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

    do ibatch=1,numbatch
       batchlow=(ibatch-1)*batchsize+1
       batchhigh=min(howmany,ibatch*batchsize)
       thisbatchsize=batchhigh-batchlow+1

       call myclock(atime)

       work(:,1:thisbatchsize,rank)=in(:,batchlow:batchhigh)

       totsize=procs*thisbatchsize*nnn*numpoints(indim)
       blocksizes(:)=thisbatchsize*nnn*numpoints(indim)

       call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

       call mpiallgather_local(work(:,:,:),totsize,blocksizes,798,comm,procs,rank)

       call myclock(btime); times(2)=times(2)+btime-atime; atime=btime

       do iproc=1,procs
          work2(:,iproc,:)=work(:,:,iproc)
       enddo

       call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

       call mult_all0(work2,out(:,batchlow:batchhigh),indim,nnn,thisbatchsize,option)

       call myclock(btime); times(3)=times(3)+btime-atime

    enddo

    deallocate(work,work2)
  
    if (debugflag.eq.42.and.myrank.eq.1.and.notiming.lt.2) then
       xcount=xcount+1
       if (xcount==1) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke2.time.dat", &
               status="unknown",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100A11)',iostat=myiostat)   "copy", "allgather","mult"
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853) 
       endif
       if (mod(xcount,100).eq.0) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke2.time.dat", &
               status="unknown", position="append",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100I11)',iostat=myiostat)  times(1:3)
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853)
       endif
    endif

  end subroutine mult_gather_gen0

  subroutine mult_circ_gen(indim,in, out,option,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: option,howmany,indim,notiming
    DATATYPE,intent(in) :: in(totpoints,howmany)
    DATATYPE,intent(out) :: out(totpoints,howmany)
    character,intent(in) :: timingdir*(*)
    integer :: nnn,mmm,ii
    nnn=1
    do ii=1,indim-1
       nnn=nnn*numpoints(ii)
    enddo
    mmm=howmany
    do ii=indim+1,3
       mmm=mmm*numpoints(ii)
    enddo
    call mult_circ_gen0(nnn,indim,in,out,option,mmm,timingdir,notiming)
  end subroutine mult_circ_gen

  subroutine mult_circ_gen0(nnn,indim,in, out,option,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: nnn,option,howmany,indim,notiming
    DATATYPE,intent(in) :: in(nnn*numpoints(indim),howmany)
    DATATYPE,intent(out) :: out(nnn*numpoints(indim),howmany)
    character,intent(in) :: timingdir*(*)
    DATATYPE ::     work(nnn*numpoints(indim),howmany),       work2(nnn*numpoints(indim),howmany) !! AUTOMATIC
    integer :: atime,btime,getlen,ibox,jbox,deltabox,ii,totsize,myiostat
    integer, save :: xcount=0, times(10)=0
    
    totsize=nnn*numpoints(indim)*howmany
    
    out(:,:)=0; work=0; work2=0

    do deltabox=0,nbox(indim)-1
       call myclock(atime)
     
       ibox=mod(nbox(indim)+boxrank(indim)-1+deltabox,nbox(indim))+1
       jbox=mod(nbox(indim)+boxrank(indim)-1-deltabox,nbox(indim))+1
    
       work(:,:)=0d0

       select case(option)
       case(1)  !! KE
          do ii=1,howmany
             call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,in(:,ii),nnn,&
                  ketot(indim)%tam(:,:,ibox,boxrank(indim)),numpoints(indim),DATAZERO, work(:,ii), nnn)
!!                ketot(indim)%mat(1,ibox,1,boxrank(indim)),gridpoints(indim),DATAZERO, work(:,ii), nnn)
          enddo
       case(2) 
          do ii=1,howmany
             call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,in(:,ii),nnn,&
                  fdtot(indim)%tam(:,:,ibox,boxrank(indim)),numpoints(indim),DATAZERO, work(:,ii), nnn)
!!                fdtot(indim)%mat(1,ibox,1,boxrank(indim)),gridpoints(indim),DATAZERO, work(:,ii), nnn)
          enddo
       case default 
          OFLWR "WHAAAAT"; CFLST
       end select

       call myclock(btime); times(1)=times(1)+btime-atime; atime=btime
     
       if (deltabox.ne.0) then

          work2(:,:)=0d0

          select case (indim)
          case(3)
             call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(1),boxrank(2),3))
          case(2)
             select case(orbparlevel)
             case(2)
                call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(1),boxrank(3),2))
             case(1)
                call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(3),boxrank(1),2))
             case default
                print *, "ACK LEVEL"; stop
             end select
          case(1)
             call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(2),boxrank(3),1))
          case default 
             print *, "ACK dim"; stop
          end select

          call myclock(btime); times(2)=times(2)+btime-atime; atime=btime
          out(:,:)=out(:,:)+work2(:,:)
       else
          out(:,:)=out(:,:)+work(:,:)
       endif
       call myclock(btime); times(3)=times(3)+btime-atime
    enddo
  
    if (debugflag.eq.42.and.myrank.eq.1.and.notiming.lt.2) then
       xcount=xcount+1
       if (xcount==1) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke2.time.dat", &
               status="unknown",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100A11)',iostat=myiostat)   "mult", "sendrecv","add"
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853) 
       endif
       if (mod(xcount,100).eq.0) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke2.time.dat", &
               status="unknown", position="append",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100I11)',iostat=myiostat)  times(1:3)
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853)
       endif
    endif

  end subroutine mult_circ_gen0

  subroutine mult_summa_gen(indim,in, out,option,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: option,howmany,indim,notiming
    DATATYPE,intent(in) :: in(totpoints,howmany)
    DATATYPE,intent(out) :: out(totpoints,howmany)
    character,intent(in) :: timingdir*(*)
    integer :: nnn,mmm,ii
    nnn=1
    do ii=1,indim-1
       nnn=nnn*numpoints(ii)
    enddo
    mmm=howmany
    do ii=indim+1,3
       mmm=mmm*numpoints(ii)
    enddo
    call mult_summa_gen0(nnn,indim,in,out,option,mmm,timingdir,notiming)
  end subroutine mult_summa_gen

  subroutine mult_summa_gen0(nnn,indim,in, out,option,howmany,timingdir,notiming)
    use myparams
    use pmpimod
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: nnn,option,howmany,indim
    DATATYPE,intent(in) :: in(nnn*numpoints(indim),howmany)
    DATATYPE,intent(out) :: out(nnn*numpoints(indim),howmany)
    DATATYPE ::     work(nnn*numpoints(indim),howmany) !! AUTOMATIC
    character,intent(in) :: timingdir*(*)
    integer :: atime,btime,notiming,getlen,ibox,ii,totsize,myiostat
    integer, save :: xcount=0, times(10)=0
    
    totsize=numpoints(indim)*nnn*howmany

    call myclock(atime)

    out(:,:)=0d0;   work=0

    call myclock(btime); times(1)=times(1)+btime-atime
    
    do ibox=1,nbox(indim)
       call myclock(atime)

       work(:,:)=0d0
       if (boxrank(indim).eq.ibox) then
          work(:,:)=in(:,:)
       endif
       call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

       select case (indim)
       case(3)
          call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(1),boxrank(2),3))
       case(2)
          select case(orbparlevel)
          case(2)
             call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(1),boxrank(3),2))
          case(1)
             call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(3),boxrank(1),2))
          case default
             print *, "ACK LEVEL"; stop
          end select
       case(1)
          call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(2),boxrank(3),1))
       case default 
          print *, "ACK dim"; stop
       end select

       call myclock(btime); times(2)=times(2)+btime-atime; atime=btime

       select case(option)
       case(1)  !! KE
          do ii=1,howmany
             call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,work(:,ii),nnn,&
                  ketot(indim)%tam(:,:,boxrank(indim),ibox),numpoints(indim),DATAONE, out(:,ii), nnn)
!!                ketot(indim)%mat(1,boxrank(indim),1,ibox),gridpoints(indim),DATAONE, out(:,ii), nnn)
          enddo
       case(2) 
          do ii=1,howmany
             call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,work(:,ii),nnn,&
                  fdtot(indim)%tam(:,:,boxrank(indim),ibox),numpoints(indim),DATAONE, out(:,ii), nnn)
!!                fdtot(indim)%mat(1,boxrank(indim),1,ibox),gridpoints(indim),DATAONE, out(:,ii), nnn)
          enddo
       case default 
          OFLWR "WHAAAAT"; CFLST
       end select

       call myclock(btime); times(3)=times(3)+btime-atime
    enddo

    if (debugflag.eq.42.and.myrank.eq.1.and.notiming.lt.2) then
       xcount=xcount+1
       if (xcount==1) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke2.time.dat", &
               status="unknown",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100A11)',iostat=myiostat)   "copy", "bcast","mult"
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853) 
       endif
       if (mod(xcount,100).eq.0) then
          open(2853, file=timingdir(1:getlen(timingdir))//"/zke2.time.dat", &
               status="unknown", position="append",iostat=myiostat)
          call checkiostat(myiostat,"opening kemult timing sincdvr")
          write(2853,'(100I11)',iostat=myiostat)  times(1:3)
          call checkiostat(myiostat,"writing kemult timing sincdvr")
          close(2853)
       endif
    endif

  end subroutine mult_summa_gen0

  subroutine mult_allone(in, out,idim,option,howmany)
    use myparams
    use pfileptrmod
    implicit none
    integer,intent(in) :: option,howmany,idim
    DATATYPE,intent(in) :: in(totpoints,howmany)
    DATATYPE, intent(out) :: out(totpoints,howmany)
    integer :: mmm,nnn,jdim

    nnn=1; mmm=1
    do jdim=1,idim-1
       nnn=nnn*numpoints(jdim)
    enddo
    do jdim=idim+1,griddim
       mmm=mmm*numpoints(jdim)
    enddo
    call mult_all0(in,out,idim,nnn,mmm*howmany,option)

  end subroutine mult_allone

  subroutine mult_all0(in, out,idim,nnn,mmm,option)
    use myparams
    use pfileptrmod
    use myprojectmod  
    implicit none
    integer,intent(in) :: idim,nnn,mmm,option
    DATATYPE,intent(in) :: in(nnn,gridpoints(idim),mmm)
    DATATYPE,intent(out) :: out(nnn,numpoints(idim),mmm)
    integer :: jj

    out(:,:,:)=0d0

    select case(option)
    case(1)  !! KE
       do jj=1,mmm
          call MYGEMM('N','N',nnn,numpoints(idim),gridpoints(idim),DATAONE,in(:,:,jj),nnn,&
               ketot(idim)%mat(:,:,:,boxrank(idim)),gridpoints(idim),DATAZERO, out(:,:,jj), nnn)
       enddo
    case(2)  !! X Y or Z derivative (real valued antisymmetric)
       do jj=1,mmm
          call MYGEMM('N','N',nnn,numpoints(idim),gridpoints(idim),DATANEGONE,in(:,:,jj),nnn,&
               fdtot(idim)%mat(:,:,:,boxrank(idim)),gridpoints(idim),DATAZERO, out(:,:,jj), nnn)
       enddo
    case default 
       OFLWR "WHAAAAT",option; CFLST
    end select

  end subroutine mult_all0

end subroutine mult_general

end module multgenmod


subroutine mult_ke(in,out,howmany,timingdir,notiming)
  use myparams
  use myprojectmod
  use multgenmod
  implicit none
  integer,intent(in) :: howmany,notiming
  character,intent(in) :: timingdir*(*)
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)

  call mult_general(1,DATAONE,DATAONE,DATAONE,in,out,howmany,timingdir,notiming)

end subroutine mult_ke


subroutine velmultiply(howmany,spfin,spfout, myxtdpot0,myytdpot0,myztdpot)
  use myparams
  use multgenmod
  implicit none
  integer,intent(in) :: howmany
  DATATYPE,intent(in) :: spfin(totpoints,howmany),myxtdpot0,myytdpot0,myztdpot
  DATATYPE,intent(out) :: spfout(totpoints,howmany)
  DATATYPE :: cx,cy,cz

  cx=(0d0,-1d0) * myxtdpot0
  cy=(0d0,-1d0) * myytdpot0
  cz=(0d0,-1d0) * myztdpot

  call mult_general(2,cx,cy,cz,spfin,spfout,howmany,"booga",2)

end subroutine velmultiply


subroutine hatom_op(howmany,inspfs, outspfs,hatomreduced)
  use myparams
  implicit none
  integer,intent(in) :: howmany
  DATATYPE,intent(out) :: outspfs(totpoints,howmany)
  DATATYPE,intent(in) :: inspfs(totpoints,howmany),hatomreduced(1)
  DATATYPE :: qq
  outspfs(:,:)=0d0
  return
  qq=inspfs(1,1);  qq=hatomreduced(1)
end subroutine hatom_op


subroutine op_contact(howmany,spfin,spfout)
  use myparams
  use pfileptrmod
  use multgenmod
  implicit none
  integer,intent(in) :: howmany
  DATATYPE,intent(in) :: spfin(numpoints(1),numpoints(2),numpoints(3),howmany)
  DATATYPE,intent(out) :: spfout(numpoints(1),numpoints(2),numpoints(3),howmany)
  DATATYPE, allocatable ::  spfderivs(:,:,:,:,:), spftemp(:,:,:,:), &
       threespfs(:,:,:,:,:), spftemp2(:,:,:,:)
  DATATYPE :: cx,cy,cz
  integer :: icenter,jj,qq(3)
  real*8 :: scoef, zcoef, pcoef
  spfout(:,:,:,:) = 0d0

  if (.not.use_contactop) then
     return
  endif

  allocate(       spfderivs(numpoints(1),numpoints(2),numpoints(3),howmany,3), &
       spftemp(numpoints(1),numpoints(2),numpoints(3),howmany), &
       spftemp2(numpoints(1),numpoints(2),numpoints(3),howmany), &
       threespfs(numpoints(1),numpoints(2),numpoints(3),howmany,3))
  spfderivs(:,:,:,:,:) = 0d0
  spftemp(:,:,:,:) = 0d0
  spftemp2(:,:,:,:) = 0d0
  threespfs(:,:,:,:,:) = 0d0


!!!    0-WAVE    !!!

  if  (contact_0coef.ne.0d0.or.auto_contactop.gt.0) then

     do icenter = 1,numcenters

        qq(:) = ( gridpoints(1:3)+centershift(:,icenter)+1 ) / 2

        if (auto_contactop.gt.0) then
           zcoef = zcoef_fun(nuccharges(icenter),spacing)
        else
           zcoef = contact_0coef
        endif

        do jj=1,3
           if (qq(jj).lt.1.or.qq(jj).gt.gridpoints(jj)) then
              OFLWR "error, can't use op_contact if nuclei are off grid",&
                   qq(1:3),gridpoints(1:3); CFLST
           endif
        enddo
        
        qq(1:3) = qq(1:3) - numpoints(1:3)*(qbox(1:3)-1)
     
        if (qq(1).ge.1.and.qq(1).le.numpoints(1) .and. &
             qq(2).ge.1.and.qq(2).le.numpoints(2) .and. &
             qq(3).ge.1.and.qq(3).le.numpoints(3) ) then
           spfout(qq(1),qq(2),qq(3),:) = spfout(qq(1),qq(2),qq(3),:) + zcoef * nuccharges(icenter) * &
                spfin(qq(1),qq(2),qq(3),:)
        endif

     enddo

  endif

!!!    P-WAVE    !!!

  if  (contact_pcoef.ne.0d0.or.auto_contactop.gt.1) then

     cx=1d0;  cy=0d0;  cz=0d0
     call mult_general(2,cx,cy,cz,spfin,spfderivs(:,:,:,:,1),howmany,"booga",2)
     cx=0d0;  cy=1d0;  cz=0d0
     call mult_general(2,cx,cy,cz,spfin,spfderivs(:,:,:,:,2),howmany,"booga",2)
     cx=0d0;  cy=0d0;  cz=1d0
     call mult_general(2,cx,cy,cz,spfin,spfderivs(:,:,:,:,3),howmany,"booga",2)
     
     threespfs(:,:,:,:,:) = 0d0

     do icenter = 1,numcenters

        qq(:) = ( gridpoints(1:3)+centershift(:,icenter)+1 ) / 2

        if (auto_contactop.gt.1) then
           pcoef = pcoef_fun(nuccharges(icenter),spacing)
        else
           pcoef = contact_pcoef
        endif

        do jj=1,3
           if (qq(jj).lt.1.or.qq(jj).gt.gridpoints(jj)) then
              OFLWR "error, can't use op_contact if nuclei are off grid",&
                   qq(1:3),gridpoints(1:3); CFLST
           endif
        enddo
        
        qq(1:3) = qq(1:3) - numpoints(1:3)*(qbox(1:3)-1)
     
        if (qq(1).ge.1.and.qq(1).le.numpoints(1) .and. &
             qq(2).ge.1.and.qq(2).le.numpoints(2) .and. &
             qq(3).ge.1.and.qq(3).le.numpoints(3) ) then
           threespfs(qq(1),qq(2),qq(3),:,1:3) = threespfs(qq(1),qq(2),qq(3),:,1:3) + nuccharges(icenter) * &
                spfderivs(qq(1),qq(2),qq(3),:,1:3) * pcoef
        endif

     enddo

     cx=1d0;  cy=0d0;  cz=0d0
     call mult_general(2,cx,cy,cz,threespfs(:,:,:,:,1),spfderivs(:,:,:,:,1),howmany,"booga",2)
     cx=0d0;  cy=1d0;  cz=0d0
     call mult_general(2,cx,cy,cz,threespfs(:,:,:,:,2),spfderivs(:,:,:,:,2),howmany,"booga",2)
     cx=0d0;  cy=0d0;  cz=1d0
     call mult_general(2,cx,cy,cz,threespfs(:,:,:,:,3),spfderivs(:,:,:,:,3),howmany,"booga",2)

     spfout(:,:,:,:) = spfout(:,:,:,:) + ( &
          spfderivs(:,:,:,:,1) + spfderivs(:,:,:,:,2) + spfderivs(:,:,:,:,3) )

  endif   !! contact_pcoef


!!!    S-WAVE    !!!!

  if  (contact_scoef.ne.0d0.or.auto_contactop.gt.0) then

     call mult_ke(spfin,spftemp(:,:,:,:),howmany,"booga",2)

     spftemp2(:,:,:,:) = 0d0

     do icenter = 1,numcenters
        
        qq(:) = ( gridpoints(1:3)+centershift(:,icenter)+1 ) / 2

        if (auto_contactop.gt.0) then
           scoef = scoef_fun(nuccharges(icenter),spacing)
        else
           scoef = contact_scoef
        endif

        do jj=1,3
           if (qq(jj).lt.1.or.qq(jj).gt.gridpoints(jj)) then
              OFLWR "error, can't use op_contact if nuclei are off grid",&
                   qq(1:3),gridpoints(1:3); CFLST
           endif
        enddo

        qq(1:3) = qq(1:3) - numpoints(1:3)*(qbox(1:3)-1)
     
        if (qq(1).ge.1.and.qq(1).le.numpoints(1) .and. &
             qq(2).ge.1.and.qq(2).le.numpoints(2) .and. &
             qq(3).ge.1.and.qq(3).le.numpoints(3) ) then
           spftemp2(qq(1),qq(2),qq(3),:) = spftemp2(qq(1),qq(2),qq(3),:) + nuccharges(icenter) * &
                spftemp(qq(1),qq(2),qq(3),:) * scoef
        endif

     enddo

     call mult_ke(spftemp2(:,:,:,:),spftemp(:,:,:,:),howmany,"booga",2)

!! factor 4 due to (-0.5)^2 in ke

     spfout(:,:,:,:) = spfout(:,:,:,:) + 4 * spftemp(:,:,:,:)

  endif  !! contact_scoef

!!!!

  deallocate(spfderivs,spftemp,spftemp2,threespfs)

contains

!   logistic(x) = (exp(x)-1)/(1+exp(x))
!   
!   f(x) = A*logistic(B*x**C)*x**D
!   
!  A,B,C,D   S COEF:
!  0.0435795761875385 0.166927732759779 3.1844419300686 0
!  A,B,C,D   Z COEF:
!  1.01091424559655 -0.227418357545392 1.75339729714461 -1.43058810066227
!  A,B,C,D   P COEF:
!  0.0388098059697418 1.06996811469877 0.881358576929761 1.74664787460762
!  VALUES AT 2, S Z and P:
!  0.0279063040714153 -0.137122647628767 0.0983859017085669

  function logistic(x)
    implicit none
    real*8, intent(in) :: x
    real*8 :: logistic
    logistic = (exp(x)-1)/(1+exp(x))
  end function logistic

  function scoef_fun(charge,space)
    implicit none
    real*8, intent(in) :: charge, space
    real*8 :: product, scoef_fun

    product = charge * space

    scoef_fun = (1d0/charge)**3 * 0.0435795761875385d0 * logistic( 0.166927732759779d0 * product**3.1844419300686d0)

  end function scoef_fun

  function zcoef_fun(charge,space)
    implicit none
    real*8, intent(in) :: charge, space
    real*8 :: product, zcoef_fun

    product = charge * space

    zcoef_fun = charge * 1.01091424559655d0 * logistic( -0.227418357545392d0 * product**1.75339729714461d0)*product**(-1.43058810066227d0)

  end function zcoef_fun

  function pcoef_fun(charge,space)
    implicit none
    real*8, intent(in) :: charge, space
    real*8 :: product, pcoef_fun

    product = charge * space

    pcoef_fun = (1d0/charge) * 0.0388098059697418d0 * logistic( 1.06996811469877d0 * product**0.881358576929761d0 )*product**1.74664787460762d0

  end function pcoef_fun

  subroutine transform_cart_to_d(iwhich,inspfs,outspfs,howmany)
    implicit none
    integer,intent(in) :: iwhich,howmany
    DATATYPE, intent(in) :: inspfs(totpoints,howmany,6)  !! xx,xy,xz,yy,yz,zz
    DATATYPE, intent(out) :: outspfs(totpoints,howmany) !! xy, xz, yz, x^2-y^2, 1/sqrt(6)*(2z^2-x^2-y^2)  (3T, 2E)
    real*8 :: transmat(5,6)
    integer :: jj

    transmat = RESHAPE( (/ &
         0d0,    0d0,   0d0,   1/sqrt(2d0),   1/sqrt(6d0),  &
         1d0,    0d0,   0d0,           0d0,           0d0,  &
         0d0,    1d0,   0d0,           0d0,           0d0,  &
         0d0,    0d0,   0d0,  -1/sqrt(2d0),   1/sqrt(6d0),  &
         0d0,    0d0,   1d0,           0d0,           0d0,  &
         0d0,    0d0,   0d0,           0d0,   2/sqrt(6d0) /), (/5,6/) )

    do jj=1,5
       print *, transmat(jj,:)
    enddo
    OFLWR "tEMPSTPOO"; CFLST
         
    outspfs(:,:) = 0d0
    do jj=1,6
       outspfs(:,:) = outspfs(:,:) + transmat(iwhich,jj) * inspfs(:,:,jj)
    enddo
  end subroutine transform_cart_to_d

end subroutine op_contact


!! REINTERPOLATE ORBS FOR HALF SPACING ONLY

subroutine reinterpolate_orbs_complex(cspfs,indims,outcspfs,outdims,num)
  use myparams
  use pfileptrmod
  implicit none
  integer, intent(in) :: indims(3),outdims(3),num
  complex*16,intent(in) :: cspfs(indims(1),indims(2),indims(3),num)
  complex*16,intent(out) ::outcspfs(outdims(1),outdims(2),outdims(3),num)
  complex*16,allocatable ::       newspfs1(:,:,:,:),newspfs2(:,:,:,:),transform(:,:)
  real*8,allocatable :: distance(:),&  !! new index minus 2 times old  
       sincval(:)
  real*8 :: current_interval,old_interval
  integer :: indim,i,j,outdim
  
  if ((indims(1).ne.indims(2).or.indims(1).ne.indims(3)).or.&
       outdims(1).ne.outdims(2).or.outdims(1).ne.outdims(3)) then
     OFLWR "reinterpolate not supported noncube",indims,outdims; CFLST
  endif

  allocate(newspfs1(outdims(1),indims(2),indims(3),num), &
       newspfs2(outdims(1),outdims(2),indims(3),num),    transform(outdims(1),indims(1)),&
       distance(1-2*indims(1):outdims(1)-2),&  !! new index minus 2 times old  
       sincval(1-2*indims(1):outdims(1)-2))

  newspfs1=0; newspfs2=0; distance=0; sincval=0
  
  indim=indims(1); outdim=outdims(1)

  current_interval=spacing*(outdim-1)
  old_interval=spacing*2*(indim-1)
  
  do i=1-2*indim,outdim-2
     ! point-slope form.  when i=1,j=1 then distance(j-2*i) = distance(-1)
 
     distance(i)=(old_interval-current_interval)/2d0 + spacing*(i+1)
     sincval(i)=mysinc(distance(i)/spacing/2)
  enddo
  do i=1,indim  !! old (coarse)
     do j=1,outdim  !! new (fine)
        transform(j,i)=sincval(j-2*i)
     enddo
  enddo

  call mult_all0_big_gen_complex(cspfs,newspfs1,indim,outdim,transform,1,indim**2*num)
  call mult_all0_big_gen_complex(newspfs1,newspfs2,indim,outdim,transform,outdim,indim*num)
  call mult_all0_big_gen_complex(newspfs2,outcspfs,indim,outdim,transform,outdim**2,num)

  deallocate(newspfs1,newspfs2,transform,distance,sincval)

contains

  function mysinc(input)
    implicit none
    real*8,intent(in) :: input
    real*8 :: mysinc
    real*8,parameter :: pi=3.141592653589793d0
    if (abs(input).lt.1d-6) then
       mysinc=1d0
    else
       mysinc=((0d0,-1d0)*exp((0d0,1d0)*pi*input)+&  !! ok conversion
            (0d0,1d0)*exp((0d0,-1d0)*pi*input))/pi/input/2
    endif
  end function mysinc

  subroutine mult_all0_big_gen_complex(in, out,indim,outdim,mat,nnn,mmm)
    implicit none
    integer,intent(in) :: indim,outdim,nnn,mmm
    complex*16,intent(in) :: in(nnn,indim,mmm),mat(outdim,indim)
    complex*16,intent(out) :: out(nnn,outdim,mmm)
    integer :: jj

    out(:,:,:)=0d0
    do jj=1,mmm
       call ZGEMM('N','T',nnn,outdim,indim,(1d0,0d0),in(:,:,jj),nnn,mat,outdim,(0d0,0d0), out(:,:,jj), nnn)
    enddo

  end subroutine mult_all0_big_gen_complex

end subroutine reinterpolate_orbs_complex


subroutine reinterpolate_orbs_real(rspfs,dims,num)
  use myparams
  use pfileptrmod
  implicit none
  integer, intent(in) :: dims(3),num
  real*8 :: rspfs(dims(1),dims(2),dims(3),num)
  OFLWR "Reinterpolate orbs not supported real valued yet"; CFLST
  rspfs(:,:,:,:)=0
end subroutine reinterpolate_orbs_real



!! For good loading boxes and pencils... also need for improvements to getinverse

subroutine splitgatherv(inlocal,outbig,bcastflag)
  use pmpimod
  use myparams
  implicit none
  logical,intent(in) :: bcastflag
  DATATYPE, intent(in) :: inlocal(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE, intent(out) :: outbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))

#ifdef REALGO
  call splitgatherv_real(inlocal,outbig,bcastflag)
#else
  call splitgatherv_complex(inlocal,outbig,bcastflag)
#endif

end subroutine splitgatherv


subroutine splitgatherv_real(inlocal,outbig,bcastflag)
  use pmpimod
  use myparams
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  logical,intent(in) :: bcastflag
  real*8, intent(in) :: inlocal(numpoints(1),numpoints(2),numpoints(3))
  real*8, allocatable :: ingather(:,:,:,:,:,:)
  real*8, intent(out) :: outbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(ingather(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))
  else
     allocate(ingather(1,1,1,1,1,1))
  endif

  ingather=0
  qqblocks(:)=totpoints
  call mygatherv_real(inlocal,ingather,qqblocks,.false.)

  if (myrank.eq.1) then
     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        outbig(:,kk,:,jj,:,ii) = ingather(:,:,:,kk,jj,ii)
     enddo
     enddo
     enddo
  endif

  deallocate(ingather)

  if (bcastflag) then
     call mympirealbcast(outbig,1,totpoints*nprocs)
  endif


end subroutine splitgatherv_real


subroutine splitgatherv_complex(inlocal,outbig,bcastflag)
  use pmpimod
  use myparams
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  logical,intent(in) :: bcastflag
  complex*16, intent(in) :: inlocal(numpoints(1),numpoints(2),numpoints(3))
  complex*16, allocatable :: ingather(:,:,:,:,:,:)
  complex*16, intent(out) :: outbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(ingather(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))
  else
     allocate(ingather(1,1,1,1,1,1))
  endif

  ingather=0
  qqblocks(:)=totpoints
  call mygatherv_complex(inlocal,ingather,qqblocks,.false.)

  if (myrank.eq.1) then
     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        outbig(:,kk,:,jj,:,ii) = ingather(:,:,:,kk,jj,ii)
     enddo
     enddo
     enddo
  endif

  deallocate(ingather)

  if (bcastflag) then
     call mympicomplexbcast(outbig,1,totpoints*nprocs)
  endif

end subroutine splitgatherv_complex


subroutine splitscatterv(inbig,outlocal)
  use pmpimod
  use myparams
  implicit none
  DATATYPE, intent(out) :: outlocal(numpoints(1),numpoints(2),numpoints(3))
  DATATYPE, intent(in) :: inbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
#ifdef REALGO
  call splitscatterv_real(inbig,outlocal)
#else
  call splitscatterv_complex(inbig,outlocal)
#endif

end subroutine splitscatterv


subroutine splitscatterv_real(inbig,outlocal)
  use pmpimod
  use myparams
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  real*8, intent(out) :: outlocal(numpoints(1),numpoints(2),numpoints(3))
  real*8, allocatable :: inscatter(:,:,:,:,:,:)
  real*8, intent(in) :: inbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(inscatter(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))
     inscatter=0
     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        inscatter(:,:,:,kk,jj,ii)=inbig(:,kk,:,jj,:,ii)
     enddo
     enddo
     enddo
  else
     allocate(inscatter(1,1,1,1,1,1))
     inscatter=0
  endif

  qqblocks(:)=totpoints
  call myscatterv_real(inscatter,outlocal,qqblocks)

  deallocate(inscatter)

end subroutine splitscatterv_real




subroutine splitscatterv_complex(inbig,outlocal)
  use pmpimod
  use myparams
  use mpisubmod   !! IN PARENT DIRECTORY
  implicit none
  complex*16, intent(out) :: outlocal(numpoints(1),numpoints(2),numpoints(3))
  complex*16, allocatable :: inscatter(:,:,:,:,:,:)
  complex*16, intent(in) :: inbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(inscatter(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))
     inscatter=0
     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        inscatter(:,:,:,kk,jj,ii)=inbig(:,kk,:,jj,:,ii)
     enddo
     enddo
     enddo
  else
     allocate(inscatter(1,1,1,1,1,1))
     inscatter=0
  endif

  qqblocks(:)=totpoints
  call myscatterv_complex(inscatter,outlocal,qqblocks)

  deallocate(inscatter)

end subroutine splitscatterv_complex
