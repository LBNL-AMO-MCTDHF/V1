!!$
!!$Apache License
!!$                           Version 2.0, January 2004
!!$                        http://www.apache.org/licenses/
!!$
!!$   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
!!$
!!$   1. Definitions.
!!$
!!$      "License" shall mean the terms and conditions for use, reproduction,
!!$      and distribution as defined by Sections 1 through 9 of this document.
!!$
!!$      "Licensor" shall mean the copyright owner or entity authorized by
!!$      the copyright owner that is granting the License.
!!$
!!$      "Legal Entity" shall mean the union of the acting entity and all
!!$      other entities that control, are controlled by, or are under common
!!$      control with that entity. For the purposes of this definition,
!!$      "control" means (i) the power, direct or indirect, to cause the
!!$      direction or management of such entity, whether by contract or
!!$      otherwise, or (ii) ownership of fifty percent (50%) or more of the
!!$      outstanding shares, or (iii) beneficial ownership of such entity.
!!$
!!$      "You" (or "Your") shall mean an individual or Legal Entity
!!$      exercising permissions granted by this License.
!!$
!!$      "Source" form shall mean the preferred form for making modifications,
!!$      including but not limited to software source code, documentation
!!$      source, and configuration files.
!!$
!!$      "Object" form shall mean any form resulting from mechanical
!!$      transformation or translation of a Source form, including but
!!$      not limited to compiled object code, generated documentation,
!!$      and conversions to other media types.
!!$
!!$      "Work" shall mean the work of authorship, whether in Source or
!!$      Object form, made available under the License, as indicated by a
!!$      copyright notice that is included in or attached to the work
!!$      (an example is provided in the Appendix below).
!!$
!!$      "Derivative Works" shall mean any work, whether in Source or Object
!!$      form, that is based on (or derived from) the Work and for which the
!!$      editorial revisions, annotations, elaborations, or other modifications
!!$      represent, as a whole, an original work of authorship. For the purposes
!!$      of this License, Derivative Works shall not include works that remain
!!$      separable from, or merely link (or bind by name) to the interfaces of,
!!$      the Work and Derivative Works thereof.
!!$
!!$      "Contribution" shall mean any work of authorship, including
!!$      the original version of the Work and any modifications or additions
!!$      to that Work or Derivative Works thereof, that is intentionally
!!$      submitted to Licensor for inclusion in the Work by the copyright owner
!!$      or by an individual or Legal Entity authorized to submit on behalf of
!!$      the copyright owner. For the purposes of this definition, "submitted"
!!$      means any form of electronic, verbal, or written communication sent
!!$      to the Licensor or its representatives, including but not limited to
!!$      communication on electronic mailing lists, source code control systems,
!!$      and issue tracking systems that are managed by, or on behalf of, the
!!$      Licensor for the purpose of discussing and improving the Work, but
!!$      excluding communication that is conspicuously marked or otherwise
!!$      designated in writing by the copyright owner as "Not a Contribution."
!!$
!!$      "Contributor" shall mean Licensor and any individual or Legal Entity
!!$      on behalf of whom a Contribution has been received by Licensor and
!!$      subsequently incorporated within the Work.
!!$
!!$   2. Grant of Copyright License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      copyright license to reproduce, prepare Derivative Works of,
!!$      publicly display, publicly perform, sublicense, and distribute the
!!$      Work and such Derivative Works in Source or Object form.
!!$
!!$   3. Grant of Patent License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      (except as stated in this section) patent license to make, have made,
!!$      use, offer to sell, sell, import, and otherwise transfer the Work,
!!$      where such license applies only to those patent claims licensable
!!$      by such Contributor that are necessarily infringed by their
!!$      Contribution(s) alone or by combination of their Contribution(s)
!!$      with the Work to which such Contribution(s) was submitted. If You
!!$      institute patent litigation against any entity (including a
!!$      cross-claim or counterclaim in a lawsuit) alleging that the Work
!!$      or a Contribution incorporated within the Work constitutes direct
!!$      or contributory patent infringement, then any patent licenses
!!$      granted to You under this License for that Work shall terminate
!!$      as of the date such litigation is filed.
!!$
!!$   4. Redistribution. You may reproduce and distribute copies of the
!!$      Work or Derivative Works thereof in any medium, with or without
!!$      modifications, and in Source or Object form, provided that You
!!$      meet the following conditions:
!!$
!!$      (a) You must give any other recipients of the Work or
!!$          Derivative Works a copy of this License; and
!!$
!!$      (b) You must cause any modified files to carry prominent notices
!!$          stating that You changed the files; and
!!$
!!$      (c) You must retain, in the Source form of any Derivative Works
!!$          that You distribute, all copyright, patent, trademark, and
!!$          attribution notices from the Source form of the Work,
!!$          excluding those notices that do not pertain to any part of
!!$          the Derivative Works; and
!!$
!!$      (d) If the Work includes a "NOTICE" text file as part of its
!!$          distribution, then any Derivative Works that You distribute must
!!$          include a readable copy of the attribution notices contained
!!$          within such NOTICE file, excluding those notices that do not
!!$          pertain to any part of the Derivative Works, in at least one
!!$          of the following places: within a NOTICE text file distributed
!!$          as part of the Derivative Works; within the Source form or
!!$          documentation, if provided along with the Derivative Works; or,
!!$          within a display generated by the Derivative Works, if and
!!$          wherever such third-party notices normally appear. The contents
!!$          of the NOTICE file are for informational purposes only and
!!$          do not modify the License. You may add Your own attribution
!!$          notices within Derivative Works that You distribute, alongside
!!$          or as an addendum to the NOTICE text from the Work, provided
!!$          that such additional attribution notices cannot be construed
!!$          as modifying the License.
!!$
!!$      You may add Your own copyright statement to Your modifications and
!!$      may provide additional or different license terms and conditions
!!$      for use, reproduction, or distribution of Your modifications, or
!!$      for any such Derivative Works as a whole, provided Your use,
!!$      reproduction, and distribution of the Work otherwise complies with
!!$      the conditions stated in this License.
!!$
!!$   5. Submission of Contributions. Unless You explicitly state otherwise,
!!$      any Contribution intentionally submitted for inclusion in the Work
!!$      by You to the Licensor shall be under the terms and conditions of
!!$      this License, without any additional terms or conditions.
!!$      Notwithstanding the above, nothing herein shall supersede or modify
!!$      the terms of any separate license agreement you may have executed
!!$      with Licensor regarding such Contributions.
!!$
!!$   6. Trademarks. This License does not grant permission to use the trade
!!$      names, trademarks, service marks, or product names of the Licensor,
!!$      except as required for reasonable and customary use in describing the
!!$      origin of the Work and reproducing the content of the NOTICE file.
!!$
!!$   7. Disclaimer of Warranty. Unless required by applicable law or
!!$      agreed to in writing, Licensor provides the Work (and each
!!$      Contributor provides its Contributions) on an "AS IS" BASIS,
!!$      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
!!$      implied, including, without limitation, any warranties or conditions
!!$      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
!!$      PARTICULAR PURPOSE. You are solely responsible for determining the
!!$      appropriateness of using or redistributing the Work and assume any
!!$      risks associated with Your exercise of permissions under this License.
!!$
!!$   8. Limitation of Liability. In no event and under no legal theory,
!!$      whether in tort (including negligence), contract, or otherwise,
!!$      unless required by applicable law (such as deliberate and grossly
!!$      negligent acts) or agreed to in writing, shall any Contributor be
!!$      liable to You for damages, including any direct, indirect, special,
!!$      incidental, or consequential damages of any character arising as a
!!$      result of this License or out of the use or inability to use the
!!$      Work (including but not limited to damages for loss of goodwill,
!!$      work stoppage, computer failure or malfunction, or any and all
!!$      other commercial damages or losses), even if such Contributor
!!$      has been advised of the possibility of such damages.
!!$
!!$   9. Accepting Warranty or Additional Liability. While redistributing
!!$      the Work or Derivative Works thereof, You may choose to offer,
!!$      and charge a fee for, acceptance of support, warranty, indemnity,
!!$      or other liability obligations and/or rights consistent with this
!!$      License. However, in accepting such obligations, You may act only
!!$      on Your own behalf and on Your sole responsibility, not on behalf
!!$      of any other Contributor, and only if You agree to indemnify,
!!$      defend, and hold each Contributor harmless for any liability
!!$      incurred by, or claims asserted against, such Contributor by reason
!!$      of your accepting any such warranty or additional liability.
!!$
!!$   END OF TERMS AND CONDITIONS
!!$
!!$   Copyright 2015 the regents of the University of California
!!$
!!$   Licensed under the Apache License, Version 2.0 (the "License");
!!$   you may not use this file except in compliance with the License.
!!$   You may obtain a copy of the License at
!!$
!!$       http://www.apache.org/licenses/LICENSE-2.0
!!$
!!$   Unless required by applicable law or agreed to in writing, software
!!$   distributed under the License is distributed on an "AS IS" BASIS,
!!$   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!$   See the License for the specific language governing permissions and
!!$   limitations under the License.


#include "Definitions.INC"


subroutine transferparams(innumspf,inspfrestrictflag,inspfmvals,inspfugrestrict,inspfugvals,outspfsmallsize,outorbparflag,multmanyflag) 
  use myparams
  implicit none
  integer :: innumspf,inspfrestrictflag,inspfmvals(innumspf), inspfugrestrict,inspfugvals(innumspf), outspfsmallsize,multmanyflag,ii
  logical, intent(out) :: outorbparflag
  numspf=innumspf;  
  outspfsmallsize=totpoints
  outorbparflag=orbparflag
  multmanyflag=0
  if (orbparflag) then
     multmanyflag=1
  endif
  ii=inspfrestrictflag; ii=inspfmvals(1); ii=inspfugvals(1); ii=inspfugrestrict;
end subroutine transferparams

subroutine twoedealloc()
end subroutine twoedealloc

subroutine call_flux_op_twoe() !mobra,moket,V2,flag) 
print *, "DOME flux_op_twoe"; stop
end subroutine call_flux_op_twoe

subroutine call_frozen_matels0() !infrozens,numfrozen,frozenkediag,frozenpotdiag)  !! returns last two.  a little cloogey
print *, "DOME CALL FROZEN MATELS."; stop
end subroutine call_frozen_matels0

subroutine call_frozen_exchange0() !inspfs,outspfs,infrozens,numfrozen)   !! rmatrix ylmvals
print *, "DOME CALL FROZEN EXCHANGE"; stop
end subroutine call_frozen_exchange0

subroutine getdensity() !density, indenmat, inspfs,numspf)
print *, "DOME GETDENSITY"; stop
end subroutine getdensity

subroutine mult_zdipole(in,out)
  use myparams
  use myprojectmod
  implicit none
  DATATYPE :: in(totpoints),out(totpoints)
  out(:)=in(:)*dipoles(:,3)
end subroutine mult_zdipole

subroutine mult_imzdipole(in, out)
  use myparams
  use myprojectmod
  implicit none
  DATATYPE :: in(totpoints),out(totpoints)
#ifdef REALGO
  out(:)=in(:)*0d0  !! avoid warn unused
#else
  out(:)=in(:)*imag(dipoles(:,3))
#endif
end subroutine mult_imzdipole

subroutine mult_ydipole(in,out)
  use myparams
  use myprojectmod
  implicit none
  DATATYPE :: in(totpoints),out(totpoints)
  out(:)=in(:)*dipoles(:,2)
end subroutine mult_ydipole

subroutine mult_imydipole(in, out)
  use myparams
  use myprojectmod
  implicit none
  DATATYPE :: in(totpoints),out(totpoints)
#ifdef REALGO
  out(:)=in(:)*0d0  !! avoid warn unused
#else
  out(:)=in(:)*imag(dipoles(:,2))
#endif
end subroutine mult_imydipole

subroutine mult_xdipole(in,out)
  use myparams
  use myprojectmod
  implicit none
  DATATYPE :: in(totpoints),out(totpoints)
  out(:)=in(:)*dipoles(:,1)
end subroutine mult_xdipole

subroutine mult_imxdipole() !in, out)
  use myparams
  use myprojectmod
  implicit none
  DATATYPE :: in(totpoints),out(totpoints)
#ifdef REALGO
  out(:)=in(:)*0d0  !! avoid warn unused
#else
  out(:)=in(:)*imag(dipoles(:,1))
#endif
end subroutine mult_imxdipole

subroutine hatomcalc()
end subroutine hatomcalc

subroutine op_frozenreduced() !inspfs,outspfs)
print *, "DOME OP FROZENREDUCED"; stop
end subroutine op_frozenreduced

subroutine restrict_spfs() !inspfs,numspf,spfmvals)
end subroutine restrict_spfs

subroutine ugrestrict_spfs() !inspfs,numspf,spfmvals)
end subroutine ugrestrict_spfs

subroutine restrict_spfs0() !inspfs,numspf,spfmvals,printflag)
end subroutine restrict_spfs0

subroutine ugrestrict_spfs0() !inspfs,numspf,spfmvals,printflag)
end subroutine ugrestrict_spfs0

subroutine bothcompact_spfs() !inspfs,outspfs,numspf,spfmvals,spfugvals)
print *, "NOT APPLICABLE BOTHCOMPACT SINCDVR"
end subroutine bothcompact_spfs

subroutine bothexpand_spfs() !inspfs,outspfs,numspf,spfmvals,spfugvals)
print *, "NOT APPLICABLE BOTHEXPAND SINCDVR"
end subroutine bothexpand_spfs

subroutine mcompact_spfs() !inspfs,outspfs,numspf,spfmvals)
print *, "NOT APPLICABLE MCOMPACT SINCDVR"; stop
end subroutine mcompact_spfs

subroutine mexpand_spfs() !inspfs,outspfs,numspf,spfmvals)
print *, "NOT APPLICABLE MEXPAND SINCDVR"; stop
end subroutine mexpand_spfs

subroutine velmultiply(spfin,spfout, myxtdpot0,myytdpot0,myztdpot)
  use myparams
  implicit none
  DATATYPE :: spfin(totpoints),spfout(totpoints),myxtdpot0,myytdpot0,myztdpot,&
       work(totpoints)
  spfout(:)=0d0
  if (abs(myxtdpot0).gt.0d0) then
     call mult_xderiv(spfin,work,1)
     spfout(:)=spfout(:)+work(:)*(0d0,1d0)
  endif
  if (abs(myytdpot0).gt.0d0) then
     call mult_yderiv(spfin,work,1)
     spfout(:)=spfout(:)+work(:)*(0d0,1d0)
  endif
  if (abs(myztdpot).gt.0d0) then
     call mult_zderiv(spfin,work,1)
     spfout(:)=spfout(:)+work(:)*(0d0,1d0)
  endif
end subroutine velmultiply

subroutine imvelmultiply() !spfin,spfout, myxtdpot0,myytdpot0,myztdpot)
print *, "DOME imVELMULTIPLY SINCDVR"; stop
end subroutine imvelmultiply

subroutine mult_imke() !in, out)
print *, "DOME MULT IMKE"; stop
end subroutine mult_imke

subroutine mult_reke() !in, out)
print *, "DOME MULT reKE"; stop
end subroutine mult_reke

recursive subroutine call_twoe_matel(inspfs10,inspfs20,twoematel,twoereduced,timingdir,notiming) 
  use myparams
  use pfileptrmod
  use myprojectmod
  implicit none
  DATATYPE,intent(in) :: inspfs10(totpoints,numspf),inspfs20(totpoints,numspf)
  DATATYPE,intent(out) :: twoematel(numspf,numspf,numspf,numspf),twoereduced(totpoints,numspf,numspf)
  character,intent(in) :: timingdir*(*)
  integer, intent(in) :: notiming



  if (fft_batchdim.lt.0.or.fft_batchdim.gt.2) then
     OFLWR "fft_batchdim error", fft_batchdim; CFLST
  endif
  if (fft_circbatchdim.gt.fft_batchdim) then
     OFLWR "Error, fft_circbatchdim can't be greater than fft_batchdim",fft_circbatchdim,fft_batchdim; CFLST
  endif
  if (fft_circbatchdim.lt.0.or.fft_circbatchdim.gt.2) then
     OFLWR "circbatchdim error", fft_circbatchdim; CFLST
  endif

  call call_twoe_matelxxx(inspfs10,inspfs20,twoematel,twoereduced,timingdir,notiming) 

end subroutine call_twoe_matel

recursive subroutine call_twoe_matelxxx(inspfs10,inspfs20,twoematel,twoereduced,timingdir,notiming) 
  use myparams
  use pmpimod
  use pfileptrmod
  use myprojectmod
  implicit none
  DATATYPE,intent(in) :: inspfs10(totpoints,numspf),inspfs20(totpoints,numspf)
  DATATYPE,intent(out) :: twoematel(numspf,numspf,numspf,numspf),twoereduced(totpoints,numspf,numspf)
  character,intent(in) :: timingdir*(*)
  integer, intent(in) :: notiming
  integer ::  spf1a, spf1b, spf2a, spf2b, itime,jtime,getlen,&
       spf2low,spf2high,index2b,index2low,index2high, firsttime,lasttime
  integer, save :: xcount=0, times(10)=0,fttimes(10)=0,qqcount=0
  DATATYPE :: twoeden03(numpoints(1),numpoints(2),numpoints(3),numspf**fft_batchdim), &
       tempden03(numpoints(1),numpoints(2),numpoints(3),numspf**fft_batchdim),twoemattemp(numspf,numspf)
!!$!!$
!!$!!$  DATATYPE ::  myden(totpoints)         !! I WAS GETTING SEGFAULTS THIS WAY 
!!$                                           !!
!!$DATATYPE,allocatable,save ::  myden(:)     !! OR THIS WAY (save)  if I don't allocate extra
!!$!OxMP THREADPRIVATE(myden)                 !!     regardless of whether or not this is added   04-26-15
!!$!!$                                           !!
!!$!!$    DATATYPE,allocatable ::  myden(:)   !! ONLY WAY THAT DIDN'T SEGFAULT BEFORE (with private)
!!$!!$                                        !!     04-28 might be good now, but leaving it this way (factor of ten)
!!$
  DATATYPE ::  myden(2*totpoints)
!!$

  times(:)=0; fttimes(:)=0;   !! ZEROING TIMES... not cumulative

  call myclock(firsttime); itime=firsttime

  if ((myrank.eq.1).and.(notiming.eq.0)) then
     if (debugflag.eq.10) then
        open(8853, file=timingdir(1:getlen(timingdir)-1)//"/twoematel.abs.time.dat", status="unknown", position="append")
        write(8853,*) "****"
        close(8853)
        call system("date --rfc-3339=ns >>"//timingdir(1:getlen(timingdir)-1)//"/twoematel.abs.time.dat")
     endif
  endif

  if (griddim.ne.3) then
     OFLWR "OOGA DIM"; CFLST
  endif
  if (fft_circbatchdim.gt.fft_batchdim) then
     OFLWR "Error, fft_circbatchdim can't be greater than fft_batchdim",fft_circbatchdim,fft_batchdim; CFLST
  endif
  if (fft_circbatchdim.lt.0.or.fft_circbatchdim.gt.2) then
     OFLWR "circbatchdim error", fft_circbatchdim; CFLST
  endif

  twoereduced(:,:,:)=0d0;   twoematel(:,:,:,:)=0

  if (notwoflag.ne.0) then
     return
  endif

!$OMP PARALLEL DEFAULT(SHARED)
!$OMP MASTER
  tempden03(:,:,:,:)=0; twoeden03(:,:,:,:)=0
!$OMP END MASTER
!$OMP END PARALLEL

  call myclock(jtime); times(1)=times(1)+jtime-itime;  
  
  select case(fft_batchdim)
  case(1)
     index2low=1; index2high=numspf
  case(2)
     index2low=1; index2high=1
  case default
     OFLWR "ACK BACTCHDIM", fft_batchdim; CFLST
     index2low=999; index2high=(-42)    !! avoid warn unused
  end select
  
  do index2b=index2low,index2high
        
     select case(fft_batchdim)
     case(1)
        spf2low=index2b;        spf2high=index2b
     case(2)
        spf2low=1; spf2high=numspf
     case default
        OFLWR "ACK BACTCHDIM", fft_batchdim; CFLST
        spf2low=42; spf2high=(-999)   !! avoid warn unused
     end select
     

 ! integrating over electron 2

     call myclock(itime)
     do spf2b=spf2low,spf2high
        do spf2a=1,numspf
           
           twoeden03(:,:,:,batchindex(spf2a,spf2b))=RESHAPE(CONJUGATE(inspfs10(:,spf2a)) * inspfs20(:,spf2b),&
                (/numpoints(1),numpoints(2),numpoints(3)/))
        enddo
     enddo
     call myclock(jtime); times(2)=times(2)+jtime-itime;

     
     call op_tinv(twoeden03(:,:,:,batchindex(1,spf2low)),twoereduced(:,1,spf2low),&
          numspf**fft_batchdim,numspf**fft_circbatchdim,&
          times(1),times(3),times(4),times(5),fttimes)



  enddo  !! DO INDEX2B


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!! reduction is performed in main MCTDHF routines NOT HERE !!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!! MYDEN IS NO LONGER THREADPRIVATE CROSSING FINGERS

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(spf2a,spf2b,twoemattemp,myden)   

  twoemattemp(:,:)=0

!!$CROSSINGFINGERS !!$ LEAVING IT THIS WAY
!!$CROSSINGFINGERS  allocate(myden(totpoints*10))

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
  do spf1b=1,numspf
  do spf1a=1,numspf
     myden(1:totpoints)=CONJUGATE(inspfs10(:,spf1a)) * inspfs20(:,spf1b)

     call MYGEMV('T',totpoints,numspf**2,DATAONE,twoereduced,totpoints,myden,1,DATAZERO,twoemattemp(:,:),1)
     twoematel(:,:,spf1a,spf1b)=twoemattemp(:,:)
  enddo
  enddo
!$OMP END DO

!!$CROSSINGFINGERS  deallocate(myden)

!$OMP END PARALLEL

  call myclock(jtime); times(6)=times(6)+jtime-itime;  
  lasttime=jtime
  times(7)=times(7)+lasttime-firsttime

!!$  if (getpot.ne.0) then
!!$     jj=numspf**2;     ii=totpoints
!!$     call MYGEMM('N','N', ii,jj,jj,DATAONE, twoereduced(:,:,:),ii,twoden(:,:,:,:),jj, DATAONE,reducedpot(:,:,:),ii)
!!$  endif

  xcount=xcount+1

  if ((myrank.eq.1).and.(notiming.eq.0)) then
     if (xcount==1) then
        open(853, file=timingdir(1:getlen(timingdir)-1)//"/twoematel.time.dat", status="unknown")
        
#ifdef MPIFLAG
        if (orbparflag) then
           if (fft_mpi_inplaceflag==1) then
              write(853,'(100A11)')   "etc", "1den", "1mpi", "F.T.", "2mpi", "dot","ALL",   &
                   "ft_copy",  "ft_conjg", "ft_ft1d","ft_tr","ft_mpi","ft_copy","ft_circ"
           else
              write(853,'(100A11)')   "etc", "1den", "1mpi", "F.T.", "2mpi", "dot","ALL",   &
                   "ft_conjg","ft_twid","ft_mpict","ft_raise","ft_tmult","ft_ft3d", "ft_circ"
           endif
        else
#endif
           write(853,'(100A11)')   "etc", "1den", "1mpi", "F.T.", "2mpi", "dot","ALL"
#ifdef MPIFLAG
        endif
#endif
        close(853)
     endif
     open(853, file=timingdir(1:getlen(timingdir)-1)//"/twoematel.time.dat", status="unknown", position="append")
     write(853,'(100I11)')  times(1:7),fttimes(1:7);        close(853)
  endif

!!! from circ subs, fttimes
!!!
!!! fttimes(7) = circ multiply

!!! from myzfft3d_par (if fft_mpi_inplaceopt == 1):

!!! fttimes(1) = copy  fttimes(2) = conjg  fttimes(3) = ft
!!! from mytranspose fttimes(4) = transpose   fttimes(5) = mpi  fttimes(6) = copy

!!! from cooleytukey (if fft_mpi_inplaceopt == 0):

!!! fttimes(1) conjugate
!!! fttimes(2) gettwiddle
!!! fttimes(3) 1d ft-slowindex
!!! fttimes(4) raise twiddle factor to power
!!! fttimes(5) multiply
!!! fttimes(6) 3d f.t.


  if (myrank.eq.1.and.(notiming.eq.0).and.debugflag.eq.10) then
        call system("date --rfc-3339=ns >>"//timingdir(1:getlen(timingdir)-1)//"/twoematel.abs.time.dat")
        open(8853, file=timingdir(1:getlen(timingdir)-1)//"/twoematel.abs.time.dat", status="unknown", position="append")
        write(8853,*) "****"
        close(8853)
  endif

  qqcount=qqcount+1
  if ((notiming.eq.0).and.debugflag.eq.10.and.qqcount.gt.1) then
     OFLWR "DEBUG10STOP"; CFLST
  endif

contains
  function batchindex(spf2a,spf2b)
    implicit none
    integer :: spf2a,spf2b,batchindex
    select case(fft_batchdim)
    case(1)
       batchindex=spf2a
    case(2)
       batchindex=spf2a+(spf2b-1)*numspf
    case default
       OFLWR "ACK BATCHINDEX FUNCTION",spf2a,spf2b; CFLST
       batchindex=999
    end select
  end function batchindex

!contains
!  subroutine myclock(mytime)
!    integer :: values(10),mytime
!    integer, parameter :: fac(5:8)=(/60*60*1000,60*1000,1000,1/)  !! hour,minute,second,millisecond
!    call date_and_time(values=values)
!    mytime=values(8)+values(7)*fac(7)+values(6)*fac(6)+values(5)*fac(5)
!  end subroutine myclock
end subroutine call_twoe_matelxxx




recursive subroutine  op_tinv(twoeden03,twoereduced,allsize,circsize,&
     times1,times3,times4,times5,fttimes)
  use myparams
  use myprojectmod
  implicit none
  integer, intent(in) :: allsize,circsize
  integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
  DATATYPE,intent(in) :: twoeden03(totpoints,allsize)
  DATATYPE,intent(out) :: twoereduced(totpoints,allsize)

  if (scalingflag.eq.0) then
     call op_tinv_notscaled(twoeden03,twoereduced,allsize,circsize,&
     times1,times3,times4,times5,fttimes)

  else
     call op_tinv_scaled(twoeden03,twoereduced,allsize,circsize,&
     times1,times3,times4,times5,fttimes)
  endif

end subroutine op_tinv


!! S = T-twiddle, T-scaled.
!! A = twoeden03
!! B = tweoreduced

!! Solve A = S B as follows
!!
!! Solve for TB
!!
!!  A = (S T^-1) (TB)
!!    = O (TB)
!!
!! Then B = T^-1 (TB)
!!
!! O = S T^-1 = T-twiddle T^-1 = 1 + (T-twiddle - T) T^-1
!!
!! O is scaled_operate_sub
!!


recursive subroutine  op_tinv_scaled(twoeden03,twoereduced,allsize,circsize,&
     times1,times3,times4,times5,fttimes)
  use myparams
  use pfileptrmod
  use myprojectmod
  implicit none
  integer, intent(in) :: allsize,circsize
  integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
  DATATYPE,intent(in) :: twoeden03(totpoints,allsize)
  DATATYPE,intent(out) :: twoereduced(totpoints,allsize)
  DATATYPE :: temp(totpoints,allsize)
  integer :: ii,numcalled
  external :: scaled_operate_sub, dummysub

  do ii=1,allsize
     temp(:,ii)=twoeden03(:,ii)*invsqrtscaleweights(:)  
  enddo

  twoereduced(:,:)=temp(:,:)  !! guess

  do ii=1,allsize
     if (orbparflag) then
        call dgsolve0(temp(:,ii),twoereduced(:,ii),numcalled, scaled_operate_sub, 0, dummysub, tinv_tol, totpoints, orblanorder, 1)
     else
        call dgsolve0(temp(:,ii),twoereduced(:,ii),numcalled, scaled_operate_sub, 0, dummysub, tinv_tol, totpoints, orblanorder, 0)
     endif
  enddo

  call mpibarrier()   !!TEMP?

  if (debugflag.ne.0) then
     OFLWR "op_tinv_scaled: iterations=",numcalled; CFL
  endif

  call op_tinv_notscaled(twoereduced(:,:),temp(:,:),allsize,circsize,&
       times1,times3,times4,times5,fttimes)

  do ii=1,allsize
     twoereduced(:,ii)=temp(:,ii)*invsqrtscaleweights(:)  
  enddo



end subroutine op_tinv_scaled


subroutine scaled_operate_sub(notusedint,in,out)
  use myparams
  implicit none
  integer :: notusedint
  DATATYPE, intent(in) :: in(totpoints)
  DATATYPE, intent(out) :: out(totpoints)
  DATATYPE :: work(totpoints),temp(totpoints)
  integer :: times1,times3,times4,times5,fttimes(10)
  real*8 :: pi

  call op_tinv_notscaled(in(:),work(:),1,1,&
       times1,times3,times4,times5,fttimes)

  pi=4d0*atan(1d0)

  work(:)=work(:)/2d0/pi

  call mult_ke_scaled(work(:),out(:),1,"booga",2)

  call mult_ke000(work(:),temp(:),1,"booga",2)
  
  out(:) = out(:) - temp(:) + in(:)

end subroutine scaled_operate_sub


recursive subroutine  op_tinv_notscaled(twoeden03,twoereduced,allsize,circsize,&
          times1,times3,times4,times5,fttimes)
  use myparams
  implicit none
  integer, intent(in) :: allsize,circsize
  integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
  DATATYPE,intent(in) :: twoeden03(numpoints(1),numpoints(2),numpoints(3),allsize)
  DATATYPE,intent(out) :: twoereduced(totpoints,allsize)

  call op_geninv_notscaled(1,twoeden03,twoereduced,allsize,circsize,&
       times1,times3,times4,times5,fttimes)

end subroutine op_tinv_notscaled


recursive subroutine  op_geninv_notscaled(iwhich,twoeden03,twoereduced,allsize,circsize,&
          times1,times3,times4,times5,fttimes)
  use myparams
  use pmpimod
  use pfileptrmod
  use myprojectmod
  implicit none
  integer, intent(in) :: allsize,circsize,iwhich
  integer, intent(inout) :: times1,times3,times4,times5,fttimes(10)
  DATATYPE,intent(in) :: twoeden03(numpoints(1),numpoints(2),numpoints(3),allsize)
  DATATYPE,intent(out) :: twoereduced(totpoints,allsize)
  integer ::   ii, itime,jtime
#ifdef MPIFLAG
  integer ::  ibox1,ibox2,ibox3,jbox1,jbox2,jbox3,jproc,iproc
  DATATYPE :: tempden03(numpoints(1),numpoints(2),numpoints(3),allsize)
#endif
  integer :: circhigh,circindex,icirc
  DATATYPE :: twoeden03huge(numpoints(1),2,numpoints(2),2,numpoints(3),2,allsize),&
       reducedhuge(numpoints(1),2,numpoints(2),2,numpoints(3),2,allsize),&
       reducedwork3d(numpoints(1),numpoints(2),numpoints(3),allsize)


  if (iwhich.lt.1.or.iwhich.gt.threedtwosize) then
     OFLWR "iwhich error",iwhich,threedtwosize; CFLST
  endif

  if (mod(allsize,circsize).ne.0) then
     OFLWR "SIZE ERROR OP_TINV",allsize,circsize; CFLST
  endif

  circhigh=allsize/circsize

!$OMP PARALLEL DEFAULT(SHARED)
!$OMP MASTER
  twoereduced(:,:)=0d0;  reducedwork3d(:,:,:,:)=0d0;
  reducedhuge(:,:,:,:,:,:,:)=0;  twoeden03huge(:,:,:,:,:,:,:)=0
!$OMP END MASTER
!$OMP END PARALLEL


  do ii=2,griddim
     if (gridpoints(ii).ne.gridpoints(1)) then
        OFLWR "DOME NONCUBE",gridpoints(:); CFLST
     endif
  enddo
#ifdef MPIFLAG
  

  if (orbparflag) then

     call myclock(itime)
     twoeden03huge(:,:,:,:,:,:,:)=0d0; 

     do ibox3=1,nbox(3)  !! processor sending
     do ibox2=1,nbox(2)  !! processor sending
     do ibox1=1,nbox(1)  !! processor sending

        iproc=rankbybox(ibox1,ibox2,ibox3)

        jbox3=(ibox3+1)/2   !! processor receiving
        jbox2=(ibox2+1)/2
        jbox1=(ibox1+1)/2

!!$        jproc=(ibox+1)/2

        jproc=rankbybox(jbox1,jbox2,jbox3)

        if (iproc.eq.myrank.and.jproc.eq.myrank) then
           twoeden03huge(:,mod(ibox1-1,2)+1,:,mod(ibox2-1,2)+1,:,mod(ibox3-1,2)+1,:)=twoeden03(:,:,:,:)
        else if (iproc.eq.myrank) then
           call mympisend(twoeden03,jproc,999,totpoints*allsize)
        else if (jproc.eq.myrank) then
           call mympirecv(tempden03,iproc,999,totpoints*allsize)
           twoeden03huge(:,mod(ibox1-1,2)+1,:,mod(ibox2-1,2)+1,:,mod(ibox3-1,2)+1,:)=tempden03(:,:,:,:)
        endif

     enddo
     enddo
     enddo
     call myclock(jtime); times3=times3+jtime-itime;
  else
#endif
     call myclock(itime)
     twoeden03huge(:,:,:,:,:,:,:)=0d0; 
     twoeden03huge(:,1,:,1,:,1,:)=twoeden03(:,:,:,:)
     call myclock(jtime); times1=times1+jtime-itime;
     
#ifdef MPIFLAG
  endif  !! orbparflag
#endif
  
#ifdef MPIFLAG
  if (orbparflag) then
     call myclock(itime); 
     
     do icirc=1,circhigh
        circindex=(icirc-1)*circsize+1
#ifdef REALGO
        call circ3d_sub_real_mpi(threed_two(:,:,:,iwhich),twoeden03huge(1,1,1,1,1,1,circindex),reducedhuge(1,1,1,1,1,1,circindex),numpoints(1),numpoints(2),numpoints(3),fttimes,circsize,fft_mpi_inplaceflag)
#else
        call circ3d_sub_mpi(threed_two(:,:,:,iwhich),twoeden03huge(1,1,1,1,1,1,circindex),reducedhuge(1,1,1,1,1,1,circindex),numpoints(1),numpoints(2),numpoints(3),fttimes,circsize,fft_mpi_inplaceflag)
#endif
     enddo
     
     call myclock(jtime); times4=times4+jtime-itime; itime=jtime

     do ibox3=1,nbox(3)  !! processor receiving
     do ibox2=1,nbox(2)
     do ibox1=1,nbox(1)

        iproc=rankbybox(ibox1,ibox2,ibox3)

        jbox3=(ibox3+nbox(3)+1)/2   !! processor sending
        jbox2=(ibox2+nbox(2)+1)/2
        jbox1=(ibox1+nbox(1)+1)/2

!!$         jproc=(ibox+nbox(3)+1)/2

        jproc=rankbybox(jbox1,jbox2,jbox3)

        if (iproc.eq.myrank.and.jproc.eq.myrank) then
           reducedwork3d(:,:,:,:)=reducedhuge(:,mod(ibox1+nbox(1)-1,2)+1,:,mod(ibox2+nbox(2)-1,2)+1,:,mod(ibox3+nbox(3)-1,2)+1,:)
        else if (iproc.eq.myrank) then
           call mympirecv(reducedwork3d(:,:,:,:),jproc,999,totpoints*allsize)
        else if (jproc.eq.myrank) then
           tempden03(:,:,:,:)=reducedhuge(:,mod(ibox1+nbox(1)-1,2)+1,:,mod(ibox2+nbox(2)-1,2)+1,:,mod(ibox3+nbox(3)-1,2)+1,:)
           call mympisend(tempden03(:,:,:,:),iproc,999,totpoints*allsize)
        endif

     enddo
     enddo
     enddo
     
     call myclock(jtime); times5=times5+jtime-itime
  else
#endif
     call myclock(itime)
     
     do icirc=1,circhigh
        circindex=(icirc-1)*circsize+1
#ifdef REALGO
        call circ3d_sub_real(threed_two(:,:,:,iwhich),twoeden03huge(1,1,1,1,1,1,circindex),reducedhuge(1,1,1,1,1,1,circindex),gridpoints(3),circsize,fft_mpi_inplaceflag)
#else
        call circ3d_sub(threed_two(:,:,:,iwhich),twoeden03huge(1,1,1,1,1,1,circindex),reducedhuge(1,1,1,1,1,1,circindex),gridpoints(3),circsize,fft_mpi_inplaceflag)
#endif
     enddo
     
     reducedwork3d(:,:,:,:)=reducedhuge(:,2,:,2,:,2,:)
     
     call myclock(jtime); times4=times4+jtime-itime
#ifdef MPIFLAG
  endif
#endif
     
  twoereduced(:,:) =RESHAPE(reducedwork3d(:,:,:,:),(/totpoints,allsize/))

  call myclock(jtime); times1=times1+jtime-itime; itime=jtime
  
end subroutine op_geninv_notscaled





!! NOW ONLY OUTPUTS ONE. CALL IN LOOP. FOR OPENMPI TRY.

subroutine mult_reducedpot(inspfs,outspf,whichspf,reducedpot)
  use myparams
  implicit none

  integer :: ispf,kspf,whichspf
  DATATYPE :: reducedpot(totpoints, numspf,numspf),  outspf(totpoints)
  DATATYPE, intent(in) :: inspfs(totpoints, numspf)

  outspf(:)=0d0

  do ispf=whichspf,whichspf
     do kspf=1,numspf

!!$ CLASSES?
!!$        if (she lls(kspf).eq.ish ell) then
!!$ reducedpot is usual notation: <ispf | kspf> so so sum over slow index kspf
                    
        outspf(:) = outspf(:) + &
             reducedpot(:,ispf,kspf) * inspfs(:,kspf)

!!$        endif
     enddo
  enddo
end subroutine mult_reducedpot



!!$subroutine get_rad(outpot)
!!$  use myparams
!!$  implicit none
!!$  integer :: jj,ii,kk
!!$  DATATYPE :: outpot(totpoints)
!!$  outpot(:)=0d0
!!$  ii=1;  kk=totpoints
!!$  do jj=1,griddim 
!!$     kk=kk/numpoints(jj)
!!$     call get_rsq_onedim(outpot,jj,qbox(jj),ii,kk)
!!$     ii=ii*numpoints(jj)
!!$  enddo
!!$  outpot(:)=sqrt(outpot)
!!$end subroutine get_rad
!!$
!!$
!!$subroutine get_rsq_onedim(out,idim,whichbox,nnn,mmm)
!!$  use myparams
!!$  use myprojectmod  
!!$  implicit none
!!$  integer :: mmm,idim,nnn,jj,whichbox,ii
!!$  DATATYPE :: out(nnn,numpoints(idim),mmm)
!!$  do jj=1,mmm
!!$     do ii=1,numpoints(idim)
!!$        out(:,ii,jj)=out(:,ii,jj) + sinepoints(idim)%mat(ii,whichbox)**2
!!$     enddo
!!$  enddo
!!$end subroutine get_rsq_onedim


subroutine get_dipoles()
  use myparams
  use myprojectmod  
  implicit none
  integer :: jj,ii,kk
  ii=1;  kk=totpoints
  do jj=1,griddim 
     kk=kk/numpoints(jj)
     call get_one_dipole(dipoles(:,jj),jj,qbox(jj),ii,kk)
     ii=ii*numpoints(jj)
  enddo
end subroutine get_dipoles


subroutine get_one_dipole(out,idim,whichbox,nnn,mmm)
  use myparams
  use myprojectmod
  implicit none
  integer :: mmm,idim,nnn,jj,whichbox,ii
  DATATYPE :: out(nnn,numpoints(idim),mmm)
  do jj=1,mmm
     do ii=1,numpoints(idim)
        out(:,ii,jj)=sinepoints(idim)%mat(ii,whichbox)
     enddo
  enddo
end subroutine get_one_dipole




subroutine mult_ke(in,out,howmany,timingdir,notiming)
  use myparams
  implicit none
  integer :: howmany,notiming
  character :: timingdir*(*)
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)

  if (scalingflag.eq.0) then
     if (maskflag.ne.0) then
        call mult_ke_mask(in, out,howmany,timingdir,notiming)
     else
        call mult_ke000(in, out,howmany,timingdir,notiming)
     endif
  else
     call mult_ke_scaled(in,out,howmany,timingdir,notiming)
  endif

end subroutine mult_ke



subroutine mult_ke_mask(in,out,howmany,timingdir,notiming)
  use myparams
  use myprojectmod
  implicit none
  integer :: howmany,notiming,ii
  character :: timingdir*(*)
  DATATYPE,intent(in) :: in(numpoints(1),numpoints(2),numpoints(3),howmany)
  DATATYPE, intent(out) :: out(numpoints(1),numpoints(2),numpoints(3),howmany)
  DATATYPE :: work(numpoints(1),numpoints(2),numpoints(3),howmany)

  work(:,:,:,:)=in(:,:,:,:)

  do ii=1,numpoints(1)
     work(ii,:,:,:)=work(ii,:,:,:)/maskfunction(1)%rmat(ii)
  enddo
  do ii=1,numpoints(2)
     work(:,ii,:,:)=work(:,ii,:,:)/maskfunction(2)%rmat(ii)
  enddo
  do ii=1,numpoints(3)
     work(:,:,ii,:)=work(:,:,ii,:)/maskfunction(3)%rmat(ii)
  enddo
 
  call mult_ke000(work, out, howmany,timingdir,notiming)

  do ii=1,numpoints(1)
     out(ii,:,:,:)=out(ii,:,:,:)*maskfunction(1)%rmat(ii)
  enddo
  do ii=1,numpoints(2)
     out(:,ii,:,:)=out(:,ii,:,:)*maskfunction(2)%rmat(ii)
  enddo
  do ii=1,numpoints(3)
     out(:,:,ii,:)=out(:,:,ii,:)*maskfunction(3)%rmat(ii)
  enddo

end subroutine mult_ke_mask


#define NEWxxSCALED
#ifdef NEWSCALED

!!$  (-0.5) J^-1/2 F J J^-1/2 = 
!!$  1/2 ( J^-3/2 t J^-1/2 + J^-1/2 t J^-3/2 + J^1/2 C F J^1/2 - J^1/2 F C J^1/2


#else

!!$  This derivation uses operator and matrix algebra as needed
!!$    hoping the DVR approximation justifies going between the two
!!$  T_ij is the matrix element for the 1D dof x
!!$    real valued scaled basis function g_i(z) = f(x(z)) with x real
!!$    are still c-orthonormal by quadrature after being multiplied by J_i^-1/2
!!$  contour is z(x)  with jacobian J(x) = d/dx z(x)
!!$  J_i = J(x_i)
!!$
!!$  T_ij     = (-0.5) (J_i J_j)^1/2 int dz g'_i(z) g'_j(z)
!!$  T_ij     = (-0.5) (J_i J_j)^1/2 int dx J(x) J^-1(x) f'_i(x) J^-1(x) f'_j(x)
!!$
!!$  insert identity: now matrices, J diagonal
!!$
!!$  T approx = (-0.5) * J^-1/2  F  J^-1  F  J^-1/2 
!!$    approx = (-0.5) J^-1/2 ( J^-1/2 F + C ) ( F J^-1/2 - C ) J^1/2
!!$  with   C = F J^1/2 - J^1/2 F     = d/dx J^-1/2(x) = -1/2 J^-3/2 d/dx J(x)
!!$
!!$  T approx = J^-1 t J^-1 + 0.5 * ( J^-1/2 C F J^-1 - J^-1 F C J^-1/2 - C^2 J^-1)
!!$  with t the unscaled T.
!!$
!!$  T = invjacobian KE invjacobian -0.5 * ( scalediag + invjacobian F scaleder - scaleder F invjacobian )
!!$
!!$       scalediag(:) = sum_i scaleder**2(:,i) * (-1)
!!$       scaleder = C J^-1/2
!!$

subroutine mult_ke_scaled(in,out,howmany,timingdir,notiming)
  use myparams
  use myprojectmod
  implicit none
  integer :: howmany,notiming,ii,jj
  character :: timingdir*(*)
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  DATATYPE :: temp(totpoints,howmany),temp2(totpoints,howmany)   !!AUTOMATIC

  do jj=1,howmany

     out(:,jj)=in(:,jj) * scalediag(:) * (-0.5d0)

  enddo

  do jj=1,3

     do ii=1,howmany
        temp(:,ii)=in(:,ii)*invjacobian(:,jj)
     enddo

     call mult_easyke(temp(:,:), temp2(:,:),howmany,jj)

     do ii=1,howmany
        out(:,ii)=out(:,ii)+temp2(:,ii)*invjacobian(:,jj)
     enddo

     call mult_easyderiv(temp(:,:), temp2(:,:),howmany,jj)

if (debugflag.eq.4141.or.debugflag.eq.3939) then

     do ii=1,howmany
        out(:,ii)=out(:,ii) - temp2(:,ii)*scaleder(:,jj)  * (-0.5d0)    !!try minus
     enddo

else

     do ii=1,howmany
        out(:,ii)=out(:,ii) + temp2(:,ii)*scaleder(:,jj)  * (-0.5d0)    !! IT'S PLUS
     enddo

endif

     do ii=1,howmany
        temp(:,ii)=in(:,ii)*scaleder(:,jj)
     enddo

     call mult_easyderiv(temp(:,:), temp2(:,:),howmany,jj)

if (debugflag.eq.4141.or.debugflag.eq.3939) then

     do ii=1,howmany
        out(:,ii)=out(:,ii) + temp2(:,ii)*invjacobian(:,jj) * (-0.5d0)   !! try plus
     enddo

else

     do ii=1,howmany
        out(:,ii)=out(:,ii) - temp2(:,ii)*invjacobian(:,jj) * (-0.5d0)   !! IT'S MINUS
     enddo

endif

  enddo

end subroutine mult_ke_scaled


#endif

subroutine mult_ke000(in, out,howmany,timingdir,notiming)
  use myparams
  implicit none
  integer :: howmany,notiming
  character :: timingdir*(*)
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)

  call mult_allpar(in,out,1,howmany,timingdir,notiming)

end subroutine mult_ke000


subroutine mult_easyderiv(in, out,howmany,which)
  use myparams
  use pfileptrmod
  implicit none
  integer,intent(in) :: howmany,which
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  select case(which)
  case(1)
     call mult_xderiv(in,out,howmany)
  case(2)
     call mult_yderiv(in,out,howmany)
  case(3)
     call mult_zderiv(in,out,howmany)
  case default
     OFLWR "oopsie",which; CFLST
  end select
end subroutine mult_easyderiv


subroutine mult_easyke(in,out,howmany,which)
  use myparams
  use pfileptrmod
  implicit none
  integer,intent(in) :: howmany,which
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  if (which.lt.1.or.which.gt.3) then
     OFLWR "which error easyke",which; CFLST
  endif
  call mult_allpar(in,out,4+which,howmany,"booga",2)

end subroutine mult_easyke


subroutine mult_xderiv(in, out,howmany)
  use myparams
  implicit none
  integer :: howmany
  character (len=200) :: timingdir="booga"
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  call mult_allpar(in,out,2,howmany,timingdir,2)
end subroutine mult_xderiv

subroutine mult_yderiv(in, out,howmany)
  use myparams
  implicit none
  integer :: howmany
  character (len=200) :: timingdir="booga"
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  call mult_allpar(in,out,3,howmany,timingdir,2)
end subroutine mult_yderiv

subroutine mult_zderiv(in, out,howmany)
  use myparams
  implicit none
  integer :: howmany
  character (len=200) :: timingdir="booga"
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  call mult_allpar(in,out,4,howmany,timingdir,2)
end subroutine mult_zderiv


subroutine mult_allpar(in, out,inoption,howmany,timingdir,notiming)
  use myparams
  use pmpimod
  use pfileptrmod
  implicit none
  integer :: idim,inoption,option,howmany,notiming
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)
  DATATYPE ::       temp(totpoints,howmany)   !! AUTOMATIC
  logical :: dodim(3)
  character :: timingdir*(*)

  if (griddim.ne.3) then
     OFLWR "ERWRESTOPPP"; CFLST
  endif

  if (inoption.lt.1.or.inoption.gt.7) then
     OFLWR "OWWOWORE WHAT?"; CFLST
     option=99
  endif
  dodim(:)=.false.

  if (inoption.eq.1.or.inoption.gt.4) then
     option=1                    !! KE options 1, 5,6,7
  else
     option=2                    !! first derivative options 2,3,4
  endif

  if (inoption.eq.1) then
     dodim(:)=.true.
  else 
     dodim(mod(inoption-2,3)+1)=.true.
  endif

  out(:,:)=0d0

  if (.not.orbparflag) then
     if (nbox(1).ne.1.or.nbox(2).ne.1.or.nbox(3).ne.1) then
        OFLWR "OOOFSSxxxF",nbox; CFLST
     endif
     do idim=1,griddim
        if (dodim(idim)) then
           call mult_allone(in,temp,idim,option,howmany)
           out(:,:)=out(:,:)+temp(:,:)
        endif
     enddo
  else
!! CHECK
     do idim=1,orbparlevel-1
        if (nbox(idim).ne.1) then
           OFLWR "OOOFSSFxx",idim,nbox(idim),1; CFLST
        endif
     enddo
     do idim=orbparlevel,3
        select case (orbparlevel)
        case(3)
           if (nbox(idim).ne.nprocs) then
              OFLWR "OOOFSSF"; CFLST
           endif
        case(2)
           if (nbox(idim).ne.sqnprocs) then
              OFLWR "OOOFSSF"; CFLST
           endif
        case(1)
           if (nbox(idim).ne.cbnprocs) then
              OFLWR "OOOFSSF"; CFLST
           endif
        end select
     enddo
!! END CHECK
     
     do idim=1,orbparlevel-1
        if (dodim(idim)) then
           call mult_allone(in,temp,idim,option,howmany)
           out(:,:)=out(:,:)+temp(:,:)
        endif
     enddo
     do idim=orbparlevel,3
        if (dodim(idim)) then
           select case(zke_paropt)
           case(0)
              call mult_circ_gen(idim,in,temp,option,howmany,timingdir,notiming)
           case(1)
              call mult_summa_gen(idim,in,temp,option,howmany,timingdir,notiming)
           case default
              OFLWR "Error, zke_paropt not recognized",zke_paropt; CFLST
           end select
           out(:,:)=out(:,:)+temp(:,:)
        endif
     enddo
  endif

end subroutine mult_allpar


!!  RATE LIMITING STEP IN CODE: MPI PARALLEL KINETIC ENERGY MULTPILICATION IN Z DIRECTION !!
!!  FOUR OPTIONS
!!
!!  zke_paropt=0   mult_circ_z   sendrecv
!!  zke_paropt=1   mult_summa_z  SUMMA  scalable universal matrix multiplication algorithm (broadcast before)

recursive subroutine mult_circ_gen(indim,in, out,option,howmany,timingdir,notiming)
  use myparams
  use pmpimod
  use pfileptrmod
  use myprojectmod  
  implicit none
  integer,intent(in) :: option,howmany,indim,notiming
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE,intent(out) :: out(totpoints,howmany)
  character,intent(in) :: timingdir*(*)
  integer :: nnn,mmm,ii
  nnn=1
  do ii=1,indim-1
     nnn=nnn*numpoints(ii)
  enddo
  mmm=howmany
  do ii=indim+1,3
     mmm=mmm*numpoints(ii)
  enddo
  call mult_circ_gen0(nnn,indim,in,out,option,mmm,timingdir,notiming)
end subroutine mult_circ_gen


recursive subroutine mult_circ_gen0(nnn,indim,in, out,option,howmany,timingdir,notiming)
  use myparams
  use pmpimod
  use pfileptrmod
  use myprojectmod  
  implicit none
  integer,intent(in) :: nnn,option,howmany,indim
  DATATYPE,intent(in) :: in(nnn*numpoints(indim),howmany)
  DATATYPE,intent(out) :: out(nnn*numpoints(indim),howmany)
  character,intent(in) :: timingdir*(*)
  DATATYPE ::     work(nnn*numpoints(indim),howmany),       work2(nnn*numpoints(indim),howmany) !! AUTOMATIC
  integer :: atime,btime,notiming,getlen,ibox,jbox,deltabox,ii,totsize
  integer, save :: xcount=0, times(10)=0
  
  totsize=nnn*numpoints(indim)*howmany

  out(:,:)=0

  do deltabox=0,nbox(indim)-1
     call myclock(atime)
     
     ibox=mod(nbox(indim)+boxrank(indim)-1+deltabox,nbox(indim))+1
     jbox=mod(nbox(indim)+boxrank(indim)-1-deltabox,nbox(indim))+1
     
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii)
     select case(option)
     case(1)  !! KE
!$OMP DO SCHEDULE(STATIC)
        do ii=1,howmany
           call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,in(:,ii),nnn,ketot(indim)%mat(1,ibox,1,boxrank(indim)),gridpoints(indim),DATAZERO, work(:,ii), nnn)
        enddo
!$OMP END DO
     case(2) 
!$OMP DO SCHEDULE(STATIC)
        do ii=1,howmany
           call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,in(:,ii),nnn,fdtot(indim)%mat(1,ibox,1,boxrank(indim)),gridpoints(indim),DATAZERO, work(:,ii), nnn)
        enddo
!$OMP END DO
     case default 
        OFLWR "WHAAAAT"; CFLST
     end select

! (Implied barrier at end parallel)
!$OMP END PARALLEL
     call myclock(btime); times(1)=times(1)+btime-atime; atime=btime
     
     if (deltabox.ne.0) then

        select case (indim)
        case(3)
           call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(1),boxrank(2),3))
        case(2)
           select case(orbparlevel)
           case(2)
              call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(1),boxrank(3),2))
           case(1)
              call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(3),boxrank(1),2))
           case default
              print *, "ACK LEVEL"; stop
           end select
        case(1)
           call mympisendrecv_local(work(:,:),work2(:,:),ibox,jbox,deltabox,totsize,BOX_COMM(boxrank(2),boxrank(3),1))
        case default 
           print *, "ACK dim"; stop
        end select

              

        call myclock(btime); times(2)=times(2)+btime-atime; atime=btime
        out(:,:)=out(:,:)+work2(:,:)
     else
        out(:,:)=out(:,:)+work(:,:)
     endif
     call myclock(btime); times(3)=times(3)+btime-atime
  enddo
  
  if (debugflag.eq.42.and.myrank.eq.1.and.notiming.lt.2) then
     xcount=xcount+1
     if (xcount==1) then
        open(2853, file=timingdir(1:getlen(timingdir)-1)//"/zke2.time.dat", status="unknown")
        write(2853,'(100A11)')   "mult", "sendrecv","add"
        close(2853) 
     endif
     if (mod(xcount,20).eq.0) then
        open(2853, file=timingdir(1:getlen(timingdir)-1)//"/zke2.time.dat", status="unknown", position="append")
        write(2853,'(100I11)')  times(1:3);        close(2853)
     endif
  endif

!! regrettably appears necessary to fix bad behavior in some cases (perhaps only with cooleytukey orbparlevel .lt. 3?)
!!  call mpibarrier()

end subroutine mult_circ_gen0



recursive subroutine mult_summa_gen(indim,in, out,option,howmany,timingdir,notiming)
  use myparams
  use pmpimod
  use pfileptrmod
  use myprojectmod  
  implicit none
  integer,intent(in) :: option,howmany,indim,notiming
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE,intent(out) :: out(totpoints,howmany)
  character,intent(in) :: timingdir*(*)
  integer :: nnn,mmm,ii
  nnn=1
  do ii=1,indim-1
     nnn=nnn*numpoints(ii)
  enddo
  mmm=howmany
  do ii=indim+1,3
     mmm=mmm*numpoints(ii)
  enddo
  call mult_summa_gen0(nnn,indim,in,out,option,mmm,timingdir,notiming)
end subroutine mult_summa_gen


recursive subroutine mult_summa_gen0(nnn,indim,in, out,option,howmany,timingdir,notiming)
  use myparams
  use pmpimod
  use pfileptrmod
  use myprojectmod  
  implicit none
  integer,intent(in) :: nnn,option,howmany,indim
  DATATYPE,intent(in) :: in(nnn*numpoints(indim),howmany)
  DATATYPE,intent(out) :: out(nnn*numpoints(indim),howmany)
  DATATYPE ::     work(nnn*numpoints(indim),howmany) !! AUTOMATIC
  character,intent(in) :: timingdir*(*)
  integer :: atime,btime,notiming,getlen,ibox,ii,totsize
  integer, save :: xcount=0, times(10)=0

  totsize=numpoints(indim)*nnn*howmany

  call myclock(atime)
  out(:,:)=0d0
  call myclock(btime); times(1)=times(1)+btime-atime

  do ibox=1,nbox(indim)
     call myclock(atime)
     if (boxrank(indim).eq.ibox) then
        work(:,:)=in(:,:)
     endif
     call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

!!$     call mympibcast(work(:,:),ibox,totsize)

     select case (indim)
     case(3)
        call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(1),boxrank(2),3))
     case(2)
        select case(orbparlevel)
        case(2)
           call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(1),boxrank(3),2))
        case(1)
           call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(3),boxrank(1),2))
        case default
           print *, "ACK LEVEL"; stop
        end select
     case(1)
        call mympibcast_local(work(:,:),ibox,totsize,BOX_COMM(boxrank(2),boxrank(3),1))
     case default 
        print *, "ACK dim"; stop
     end select

     call myclock(btime); times(2)=times(2)+btime-atime; atime=btime

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii,atime,btime)
     select case(option)
     case(1)  !! KE
!$OMP DO SCHEDULE(STATIC)
        do ii=1,howmany
           call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,work(:,ii),nnn,ketot(indim)%mat(1,boxrank(indim),1,ibox),gridpoints(indim),DATAONE, out(:,ii), nnn)
        enddo
!$OMP END DO
     case(2) 
!$OMP DO SCHEDULE(STATIC)
        do ii=1,howmany
           call MYGEMM('N','T',nnn,numpoints(indim),numpoints(indim),DATAONE,work(:,ii),nnn,fdtot(indim)%mat(1,boxrank(indim),1,ibox),gridpoints(indim),DATAONE, out(:,ii), nnn)
        enddo
!$OMP END DO
     case default 
        OFLWR "WHAAAAT"; CFLST
     end select

! (Implied barrier at end parallel)
!$OMP END PARALLEL
     call myclock(btime); times(3)=times(3)+btime-atime
  enddo

  if (debugflag.eq.42.and.myrank.eq.1.and.notiming.lt.2) then
     xcount=xcount+1
     if (xcount==1) then
        open(2853, file=timingdir(1:getlen(timingdir)-1)//"/zke2.time.dat", status="unknown")
        write(2853,'(100A11)')   "copy", "bcast","mult"
        close(2853) 
     endif
     if (mod(xcount,20).eq.0) then
        open(2853, file=timingdir(1:getlen(timingdir)-1)//"/zke2.time.dat", status="unknown", position="append")
        write(2853,'(100I11)')  times(1:3);        close(2853)
     endif
  endif
!! regrettably appears necessary to fix bad behavior in some cases (perhaps only with cooleytukey orbparlevel .lt. 3?)
!!  call mpibarrier()

end subroutine mult_summa_gen0



subroutine mult_allone(in, out,idim,option,howmany)
  use myparams
  use pfileptrmod
  implicit none
  integer :: mmm,idim,nnn,jdim,option,howmany
  DATATYPE,intent(in) :: in(totpoints,howmany)
  DATATYPE, intent(out) :: out(totpoints,howmany)

  nnn=1; mmm=1
  do jdim=1,idim-1
     nnn=nnn*numpoints(jdim)
  enddo
  do jdim=idim+1,griddim
     mmm=mmm*numpoints(jdim)
  enddo
  call mult_all0(in,out,idim,nnn,mmm*howmany,option)

end subroutine mult_allone


recursive subroutine mult_all0(in, out,idim,nnn,mmm,option)
  use myparams
  use pfileptrmod
  use myprojectmod  
  implicit none
  integer :: mmm,idim,nnn,jj,option
  DATATYPE,intent(in) :: in(nnn,numpoints(idim),mmm)
  DATATYPE,intent(out) :: out(nnn,numpoints(idim),mmm)

  select case(option)
  case(1)  !! KE
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(jj)
!$OMP DO SCHEDULE(STATIC)
     do jj=1,mmm
        call MYGEMM('N','T',nnn,numpoints(idim),numpoints(idim),DATAONE,in(:,:,jj),nnn,ketot(idim)%mat(1,1,1,1),gridpoints(idim),DATAZERO, out(:,:,jj), nnn)
     enddo
!$OMP END DO
!$OMP END PARALLEL
  case(2)  !! X Y or Z derivative (real valued antisymmetric)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(jj)
!$OMP DO SCHEDULE(STATIC)
     do jj=1,mmm
        call MYGEMM('N','T',nnn,numpoints(idim),numpoints(idim),DATAONE,in(:,:,jj),nnn,fdtot(idim)%mat(1,1,1,1),gridpoints(idim),DATAZERO, out(:,:,jj), nnn)
     enddo
!$OMP END DO
!$OMP END PARALLEL
  case default 
     OFLWR "WHAAAAT"; CFLST
  end select
end subroutine mult_all0



!! (do need this -- set to zero)
subroutine hatom_matel(inspfs1, inspfs2, hatommatel,numberspf) 
  use myparams
  implicit none
  integer :: numberspf
  DATATYPE :: inspfs1(totpoints,numberspf), inspfs2(totpoints,numberspf),hatommatel(numberspf,numberspf),qq
  hatommatel(:,:)=0d0; qq=inspfs2(1,1); qq=inspfs1(1,1)
end subroutine hatom_matel

subroutine hatom_op(inspf, outspf)
  use myparams
  implicit none
  DATATYPE :: inspf(totpoints),outspf(totpoints),qq
  outspf(:)=0d0
  qq=inspf(1)
end subroutine hatom_op


function mysinc(input)
  implicit none
  real*8 :: input,mysinc
  real*8 :: pi=3.141592653589793d0
  if (abs(input).lt.1d-6) then
     mysinc=1d0
  else
     mysinc=((0d0,-1d0)*exp((0d0,1d0)*pi*input)+(0d0,1d0)*exp((0d0,-1d0)*pi*input))/pi/input/2
  endif
end function mysinc


!! REINTERPOLATE ORBS FOR HALF SPACING ONLY

subroutine reinterpolate_orbs_complex(cspfs,indims,outcspfs,outdims,num)
  use myparams
  use pfileptrmod
  implicit none
  integer, intent(in) :: indims(3),outdims(3),num
  integer :: indim,i,j,outdim
  complex*16 :: cspfs(indims(1),indims(2),indims(3),num), &
       newspfs1(outdims(1),indims(2),indims(3),num), &
       newspfs2(outdims(1),outdims(2),indims(3),num), &
       outcspfs(outdims(1),outdims(2),outdims(3),num), &
       transform(outdims(1),indims(1))
  real*8 :: distance(1-2*indims(1):outdims(1)-2),&  !! new index minus 2 times old  
       sincval(1-2*indims(1):outdims(1)-2),mysinc,current_interval,old_interval
  
  if ((indims(1).ne.indims(2).or.indims(1).ne.indims(3)).or.&
       outdims(1).ne.outdims(2).or.outdims(1).ne.outdims(3)) then
     OFLWR "reinterpolate not supported noncube",indims,outdims; CFLST
  endif
  
  indim=indims(1); outdim=outdims(1)

  current_interval=spacing*(outdim-1)
  old_interval=spacing*2*(indim-1)
  
  do i=1-2*indim,outdim-2
     ! point-slope form.  when i=1,j=1 then distance(j-2*i) = distance(-1)
 
     distance(i)=(old_interval-current_interval)/2d0 + spacing*(i+1)
     sincval(i)=mysinc(distance(i)/spacing/2)
  enddo
  do i=1,indim  !! old (coarse)
     do j=1,outdim  !! new (fine)
        transform(j,i)=sincval(j-2*i)
     enddo
  enddo

  call mult_all0_big_gen_complex(cspfs,newspfs1,indim,outdim,transform,1,indim**2*num)
  call mult_all0_big_gen_complex(newspfs1,newspfs2,indim,outdim,transform,outdim,indim*num)
  call mult_all0_big_gen_complex(newspfs2,outcspfs,indim,outdim,transform,outdim**2,num)

end subroutine reinterpolate_orbs_complex

recursive subroutine mult_all0_big_gen_complex(in, out,indim,outdim,mat,nnn,mmm)
  implicit none
  integer :: mmm,nnn,jj,indim,outdim
  complex*16 :: in(nnn,indim,mmm),out(nnn,outdim,mmm),mat(outdim,indim)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(jj)
!$OMP DO SCHEDULE(STATIC)
  do jj=1,mmm
     call ZGEMM('N','T',nnn,outdim,indim,(1d0,0d0),in(:,:,jj),nnn,mat,outdim,(0d0,0d0), out(:,:,jj), nnn)
  enddo
!$OMP END DO
!$OMP END PARALLEL
end subroutine mult_all0_big_gen_complex

subroutine reinterpolate_orbs_real(rspfs,dims,num)
  use myparams
  use pfileptrmod
  implicit none
  integer, intent(in) :: dims(3),num
  real*8 :: rspfs(dims(1),dims(2),dims(3),num)
  OFLWR "Reinterpolate orbs not supported real valued yet"; CFLST
  rspfs(:,:,:,:)=0
end subroutine reinterpolate_orbs_real



!! For good loading boxes and pencils... also need for improvements to getinverse

subroutine splitgatherv_real(inlocal,outbig,bcastflag)
  use pmpimod
  use myparams
  implicit none
  logical,intent(in) :: bcastflag
  real*8, intent(in) :: inlocal(numpoints(1),numpoints(2),numpoints(3))
  real*8, allocatable :: ingather(:,:,:,:,:,:)
  real*8, intent(out) :: outbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(ingather(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))
  else
     allocate(ingather(1,1,1,1,1,1))
  endif

  qqblocks(:)=totpoints
  call mygatherv_real(inlocal,ingather,qqblocks,.false.)

  if (myrank.eq.1) then
     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        outbig(:,kk,:,jj,:,ii) = ingather(:,:,:,kk,jj,ii)
     enddo
     enddo
     enddo
  endif

  deallocate(ingather)

  if (bcastflag) then
     call mympirealbcast(outbig,1,totpoints*nprocs)
  endif


end subroutine splitgatherv_real


subroutine splitgatherv_complex(inlocal,outbig,bcastflag)
  use pmpimod
  use myparams
  implicit none
  logical,intent(in) :: bcastflag
  complex*16, intent(in) :: inlocal(numpoints(1),numpoints(2),numpoints(3))
  complex*16, allocatable :: ingather(:,:,:,:,:,:)
  complex*16, intent(out) :: outbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(ingather(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))
  else
     allocate(ingather(1,1,1,1,1,1))
  endif

  qqblocks(:)=totpoints
  call mygatherv_complex(inlocal,ingather,qqblocks,.false.)

  if (myrank.eq.1) then
     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        outbig(:,kk,:,jj,:,ii) = ingather(:,:,:,kk,jj,ii)
     enddo
     enddo
     enddo
  endif

  deallocate(ingather)

  if (bcastflag) then
     call mympicomplexbcast(outbig,1,totpoints*nprocs)
  endif


end subroutine splitgatherv_complex



subroutine splitscatterv_real(inbig,outlocal)
  use pmpimod
  use myparams
  implicit none
  real*8, intent(out) :: outlocal(numpoints(1),numpoints(2),numpoints(3))
  real*8, allocatable :: inscatter(:,:,:,:,:,:)
  real*8, intent(in) :: inbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(inscatter(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))

     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        inscatter(:,:,:,kk,jj,ii)=inbig(:,kk,:,jj,:,ii)
     enddo
     enddo
     enddo

  else
     allocate(inscatter(1,1,1,1,1,1))
  endif

  qqblocks(:)=totpoints
  call myscatterv_real(inscatter,outlocal,qqblocks)


  deallocate(inscatter)

end subroutine splitscatterv_real




subroutine splitscatterv_complex(inbig,outlocal)
  use pmpimod
  use myparams
  implicit none
  complex*16, intent(out) :: outlocal(numpoints(1),numpoints(2),numpoints(3))
  complex*16, allocatable :: inscatter(:,:,:,:,:,:)
  complex*16, intent(in) :: inbig(numpoints(1),procsplit(1),numpoints(2),procsplit(2),numpoints(3),procsplit(3))
  integer :: qqblocks(nprocs)
  integer :: ii,jj,kk

  if (myrank.eq.1) then
     allocate(inscatter(numpoints(1),numpoints(2),numpoints(3),procsplit(1),procsplit(2),procsplit(3)))

     do ii=1,procsplit(3)
     do jj=1,procsplit(2)
     do kk=1,procsplit(1)
        inscatter(:,:,:,kk,jj,ii)=inbig(:,kk,:,jj,:,ii)
     enddo
     enddo
     enddo

  else
     allocate(inscatter(1,1,1,1,1,1))
  endif

  qqblocks(:)=totpoints
  call myscatterv_complex(inscatter,outlocal,qqblocks)


  deallocate(inscatter)

end subroutine splitscatterv_complex


