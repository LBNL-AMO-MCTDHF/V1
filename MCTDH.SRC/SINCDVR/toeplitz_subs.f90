!! ALL MODULES
!!$
!!$Apache License
!!$                           Version 2.0, January 2004
!!$                        http://www.apache.org/licenses/
!!$
!!$   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
!!$
!!$   1. Definitions.
!!$
!!$      "License" shall mean the terms and conditions for use, reproduction,
!!$      and distribution as defined by Sections 1 through 9 of this document.
!!$
!!$      "Licensor" shall mean the copyright owner or entity authorized by
!!$      the copyright owner that is granting the License.
!!$
!!$      "Legal Entity" shall mean the union of the acting entity and all
!!$      other entities that control, are controlled by, or are under common
!!$      control with that entity. For the purposes of this definition,
!!$      "control" means (i) the power, direct or indirect, to cause the
!!$      direction or management of such entity, whether by contract or
!!$      otherwise, or (ii) ownership of fifty percent (50%) or more of the
!!$      outstanding shares, or (iii) beneficial ownership of such entity.
!!$
!!$      "You" (or "Your") shall mean an individual or Legal Entity
!!$      exercising permissions granted by this License.
!!$
!!$      "Source" form shall mean the preferred form for making modifications,
!!$      including but not limited to software source code, documentation
!!$      source, and configuration files.
!!$
!!$      "Object" form shall mean any form resulting from mechanical
!!$      transformation or translation of a Source form, including but
!!$      not limited to compiled object code, generated documentation,
!!$      and conversions to other media types.
!!$
!!$      "Work" shall mean the work of authorship, whether in Source or
!!$      Object form, made available under the License, as indicated by a
!!$      copyright notice that is included in or attached to the work
!!$      (an example is provided in the Appendix below).
!!$
!!$      "Derivative Works" shall mean any work, whether in Source or Object
!!$      form, that is based on (or derived from) the Work and for which the
!!$      editorial revisions, annotations, elaborations, or other modifications
!!$      represent, as a whole, an original work of authorship. For the purposes
!!$      of this License, Derivative Works shall not include works that remain
!!$      separable from, or merely link (or bind by name) to the interfaces of,
!!$      the Work and Derivative Works thereof.
!!$
!!$      "Contribution" shall mean any work of authorship, including
!!$      the original version of the Work and any modifications or additions
!!$      to that Work or Derivative Works thereof, that is intentionally
!!$      submitted to Licensor for inclusion in the Work by the copyright owner
!!$      or by an individual or Legal Entity authorized to submit on behalf of
!!$      the copyright owner. For the purposes of this definition, "submitted"
!!$      means any form of electronic, verbal, or written communication sent
!!$      to the Licensor or its representatives, including but not limited to
!!$      communication on electronic mailing lists, source code control systems,
!!$      and issue tracking systems that are managed by, or on behalf of, the
!!$      Licensor for the purpose of discussing and improving the Work, but
!!$      excluding communication that is conspicuously marked or otherwise
!!$      designated in writing by the copyright owner as "Not a Contribution."
!!$
!!$      "Contributor" shall mean Licensor and any individual or Legal Entity
!!$      on behalf of whom a Contribution has been received by Licensor and
!!$      subsequently incorporated within the Work.
!!$
!!$   2. Grant of Copyright License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      copyright license to reproduce, prepare Derivative Works of,
!!$      publicly display, publicly perform, sublicense, and distribute the
!!$      Work and such Derivative Works in Source or Object form.
!!$
!!$   3. Grant of Patent License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      (except as stated in this section) patent license to make, have made,
!!$      use, offer to sell, sell, import, and otherwise transfer the Work,
!!$      where such license applies only to those patent claims licensable
!!$      by such Contributor that are necessarily infringed by their
!!$      Contribution(s) alone or by combination of their Contribution(s)
!!$      with the Work to which such Contribution(s) was submitted. If You
!!$      institute patent litigation against any entity (including a
!!$      cross-claim or counterclaim in a lawsuit) alleging that the Work
!!$      or a Contribution incorporated within the Work constitutes direct
!!$      or contributory patent infringement, then any patent licenses
!!$      granted to You under this License for that Work shall terminate
!!$      as of the date such litigation is filed.
!!$
!!$   4. Redistribution. You may reproduce and distribute copies of the
!!$      Work or Derivative Works thereof in any medium, with or without
!!$      modifications, and in Source or Object form, provided that You
!!$      meet the following conditions:
!!$
!!$      (a) You must give any other recipients of the Work or
!!$          Derivative Works a copy of this License; and
!!$
!!$      (b) You must cause any modified files to carry prominent notices
!!$          stating that You changed the files; and
!!$
!!$      (c) You must retain, in the Source form of any Derivative Works
!!$          that You distribute, all copyright, patent, trademark, and
!!$          attribution notices from the Source form of the Work,
!!$          excluding those notices that do not pertain to any part of
!!$          the Derivative Works; and
!!$
!!$      (d) If the Work includes a "NOTICE" text file as part of its
!!$          distribution, then any Derivative Works that You distribute must
!!$          include a readable copy of the attribution notices contained
!!$          within such NOTICE file, excluding those notices that do not
!!$          pertain to any part of the Derivative Works, in at least one
!!$          of the following places: within a NOTICE text file distributed
!!$          as part of the Derivative Works; within the Source form or
!!$          documentation, if provided along with the Derivative Works; or,
!!$          within a display generated by the Derivative Works, if and
!!$          wherever such third-party notices normally appear. The contents
!!$          of the NOTICE file are for informational purposes only and
!!$          do not modify the License. You may add Your own attribution
!!$          notices within Derivative Works that You distribute, alongside
!!$          or as an addendum to the NOTICE text from the Work, provided
!!$          that such additional attribution notices cannot be construed
!!$          as modifying the License.
!!$
!!$      You may add Your own copyright statement to Your modifications and
!!$      may provide additional or different license terms and conditions
!!$      for use, reproduction, or distribution of Your modifications, or
!!$      for any such Derivative Works as a whole, provided Your use,
!!$      reproduction, and distribution of the Work otherwise complies with
!!$      the conditions stated in this License.
!!$
!!$   5. Submission of Contributions. Unless You explicitly state otherwise,
!!$      any Contribution intentionally submitted for inclusion in the Work
!!$      by You to the Licensor shall be under the terms and conditions of
!!$      this License, without any additional terms or conditions.
!!$      Notwithstanding the above, nothing herein shall supersede or modify
!!$      the terms of any separate license agreement you may have executed
!!$      with Licensor regarding such Contributions.
!!$
!!$   6. Trademarks. This License does not grant permission to use the trade
!!$      names, trademarks, service marks, or product names of the Licensor,
!!$      except as required for reasonable and customary use in describing the
!!$      origin of the Work and reproducing the content of the NOTICE file.
!!$
!!$   7. Disclaimer of Warranty. Unless required by applicable law or
!!$      agreed to in writing, Licensor provides the Work (and each
!!$      Contributor provides its Contributions) on an "AS IS" BASIS,
!!$      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
!!$      implied, including, without limitation, any warranties or conditions
!!$      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
!!$      PARTICULAR PURPOSE. You are solely responsible for determining the
!!$      appropriateness of using or redistributing the Work and assume any
!!$      risks associated with Your exercise of permissions under this License.
!!$
!!$   8. Limitation of Liability. In no event and under no legal theory,
!!$      whether in tort (including negligence), contract, or otherwise,
!!$      unless required by applicable law (such as deliberate and grossly
!!$      negligent acts) or agreed to in writing, shall any Contributor be
!!$      liable to You for damages, including any direct, indirect, special,
!!$      incidental, or consequential damages of any character arising as a
!!$      result of this License or out of the use or inability to use the
!!$      Work (including but not limited to damages for loss of goodwill,
!!$      work stoppage, computer failure or malfunction, or any and all
!!$      other commercial damages or losses), even if such Contributor
!!$      has been advised of the possibility of such damages.
!!$
!!$   9. Accepting Warranty or Additional Liability. While redistributing
!!$      the Work or Derivative Works thereof, You may choose to offer,
!!$      and charge a fee for, acceptance of support, warranty, indemnity,
!!$      or other liability obligations and/or rights consistent with this
!!$      License. However, in accepting such obligations, You may act only
!!$      on Your own behalf and on Your sole responsibility, not on behalf
!!$      of any other Contributor, and only if You agree to indemnify,
!!$      defend, and hold each Contributor harmless for any liability
!!$      incurred by, or claims asserted against, such Contributor by reason
!!$      of your accepting any such warranty or additional liability.
!!$
!!$   END OF TERMS AND CONDITIONS
!!$
!!$   Copyright 2016 the regents of the University of California
!!$
!!$   Licensed under the Apache License, Version 2.0 (the "License");
!!$   you may not use this file except in compliance with the License.
!!$   You may obtain a copy of the License at
!!$
!!$       http://www.apache.org/licenses/LICENSE-2.0
!!$
!!$   Unless required by applicable law or agreed to in writing, software
!!$   distributed under the License is distributed on an "AS IS" BASIS,
!!$   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!$   See the License for the specific language governing permissions and
!!$   limitations under the License.


#ifdef FFTWFLAG

module fft3dsubmod
contains

  subroutine myzfft3d(in,out,dim1,dim2,dim3,howmany)
    use ftoutmod
    use, intrinsic :: iso_c_binding
    implicit none
    include "fftw3.f03"
    integer, intent(in) :: dim1,dim2,dim3,howmany
    complex*16 :: in(dim1,dim2,dim3,howmany)  !! cannot be declared intent(in)...hmmm...
    complex*16, intent(out) :: out(dim1,dim2,dim3,howmany)
    integer, parameter :: maxplans=3
    type(C_PTR),save :: plans(maxplans)
    integer, save :: plandims(3,maxplans)=-999, planhowmany(maxplans)=-999
    integer,save :: icalleds(maxplans)=0, numplans=0
    integer :: ostride,istride,onembed(3),inembed(3),idist,odist, dims(3),iplan,thisplan

    dims(:)=(/dim3,dim2,dim1/)
    inembed(:)=dims(:); onembed(:)=dims(:); idist=dim1*dim2*dim3; odist=dim1*dim2*dim3; istride=1; ostride=1; 

    if (numplans.eq.0) then
       numplans=1
       thisplan=1
       plandims(:,thisplan)=dims(:); planhowmany(thisplan)=howmany
    else
       thisplan= -99
       do iplan=1,numplans
          if (plandims(1,iplan).eq.dims(1).and.&
               plandims(2,iplan).eq.dims(2).and.&
               plandims(3,iplan).eq.dims(3).and.&
               planhowmany(iplan).eq.howmany) then
             if (icalleds(iplan).eq.0) then
                print *, "ERROR, plan not done ",iplan,dims(:),howmany; call mpistop()
             endif
             thisplan=iplan
             exit
          endif
       enddo
       if (thisplan.eq.-99) then
          if (numplans.eq.maxplans) then
             print *,  "all plans taken!", maxplans; call mpistop()
          endif
          numplans=numplans+1
          thisplan=numplans
          plandims(:,thisplan)=dims(:); planhowmany(thisplan)=howmany
       endif
    endif
    if (icalleds(thisplan).eq.0) then
       if (ftoutflag.ne.0) then
          print *, "       Making a 3D fft plan ", thisplan, dims, howmany
       endif
       plans(thisplan) = fftw_plan_many_dft(3,dims,howmany,in,inembed,istride,idist,out,&
            onembed,ostride,odist,FFTW_FORWARD,FFTW_EXHAUSTIVE) 
       if (ftoutflag.ne.0) then
          print *, "        ...ok, made a 3D fft plan ", thisplan, dims, howmany
       endif
    endif
    icalleds(thisplan)=1    

    call fftw_execute_dft(plans(thisplan), in,out)

  end subroutine myzfft3d

end module fft3dsubmod

#else

module fft3dsubmod
contains

  subroutine fftblock_withtranspose(inout,dim1,dim2,dim3,howmany)
    use fft1dsubmod
    implicit none
    integer :: dim1,dim2,dim3,howmany
!!!!  is dimensioned (dim1,dim2,dim3) on input. !!!!
    complex*16,intent(inout) :: inout(dim2,dim3,dim1,howmany) 
    complex*16 :: work1(dim1,dim2,dim3,howmany)  !! AUTOMATIC
    integer :: i

    work1=0
    call myzfft1d(inout,work1,dim1,dim2*dim3*howmany)
    do i=1,dim1
       inout(:,:,i,:)=work1(i,:,:,:)
    enddo
  end subroutine fftblock_withtranspose

  subroutine myzfft3d(in,out,dim1,dim2,dim3,howmany)
    implicit none
    integer :: dim1,dim2,dim3,howmany
    complex*16, intent(in) :: in(dim1,dim2,dim3,howmany)
    complex*16, intent(out) :: out(dim1,dim2,dim3,howmany)
    out(:,:,:,:)=in(:,:,:,:)
    call fftblock_withtranspose(out,dim1,dim2,dim3,howmany)
    call fftblock_withtranspose(out,dim2,dim3,dim1,howmany)
    call fftblock_withtranspose(out,dim3,dim1,dim2,howmany)
  end subroutine myzfft3d

end module fft3dsubmod

#endif



#ifdef MPIFLAG

module fftparsubmod
  use mpisubmod   !! IN PARENT DIRECTORY
  use clockmod      !! IN PARENT DIRECTORY

contains

!! times(1) = transpose   times(2) = mpi  times(3) = copy
!!   (123) -> (231)

  subroutine mytranspose_complex(in,out,blocksize,howmany,times,nprocs1,nprocs2)
    use pmpimod  !! box_comm
    implicit none
    integer,intent(in) :: blocksize,howmany,nprocs1,nprocs2
    integer,intent(inout) :: times(3)
    complex*16,intent(in) :: in(nprocs1*blocksize,nprocs2*blocksize,blocksize,howmany)
    complex*16,intent(out) :: out(nprocs1*blocksize,nprocs2*blocksize,blocksize,howmany)
    integer :: atime,btime,i,count,ii,iproc,j
    complex*16 :: intranspose(nprocs2*blocksize,blocksize,blocksize,howmany,nprocs1)  !!AUTOMATIC
    complex*16 :: outtemp(nprocs2*blocksize,blocksize,blocksize,howmany,nprocs1)      !!AUTOMATIC
    complex*16 :: outone(nprocs2*blocksize,blocksize,blocksize,nprocs1)               !!AUTOMATIC
    complex*16 :: inchop(blocksize,nprocs2*blocksize,blocksize,howmany)              !!AUTOMATIC

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!    (123)->(231)    !!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
    call myclock(atime)

    intranspose=0d0; outtemp=0; outone=0; inchop=0

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii,i)    !! IPROC IS SHARED (GOES WITH BARRIER, INCHOP SHARED)

    do iproc=1,nprocs1

       inchop(:,:,:,:)=in((iproc-1)*blocksize+1:iproc*blocksize,:,:,:)

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
       do ii=1,howmany
          do i=1,blocksize

!! (123)->(231)  (:,:,7) -> (:,7,:)
!! (123)->(231)  (:,5,7) -> (5,7,:)

             intranspose(:,:,i,ii,iproc)=inchop(i,:,:,ii)

          enddo
       enddo
!$OMP END DO
!! *** OMP BARRIER *** !!   if inchop & iproc are shared
!$OMP BARRIER
    enddo

!$OMP END PARALLEL

    call myclock(btime); times(1)=times(1)+btime-atime; atime=btime

    outtemp(:,:,:,:,:)=0d0
  
    count=blocksize**3 * nprocs2 * howmany

    if (nprocs1.eq.nprocs2) then  !! orbparlevel=3

!! 231  (:,7,:) -> (:,:,7)

       call mympialltoall_complex(intranspose,outtemp,count)

    else

!! 231  (5,7,:) -> (7,5,:)

       call mympisendrecv_complex(intranspose,outtemp,&
            rankbybox(boxrank(1),boxrank(3),boxrank(2)), rankbybox(boxrank(1),boxrank(3),boxrank(2)), &
            999,count*nprocs1)

       intranspose(:,:,:,:,:)=outtemp(:,:,:,:,:)

!! 231  (7,5,:) -> (:,5,7)

       call mympialltoall_complex_local(intranspose,outtemp,count,BOX_COMM(1,boxrank(2),3))

    endif

    call myclock(btime); times(2)=times(2)+btime-atime; atime=btime

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(i,j)  !! ii IS SHARED (OUTTEMP IS SHARED; BARRIER)
    do ii=1,howmany

       outone(:,:,:,:)=outtemp(:,:,:,ii,:)
       if (nprocs1.eq.nprocs2) then

!! (231) collecting middle index, 3.. have first index,2

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
          do i=1,blocksize
             do j=1,nprocs1*blocksize
                out(j,:,i,ii)=RESHAPE(outone(j,:,i,:),(/nprocs1*blocksize/))
             enddo
          enddo
!$OMP END DO
!! *** OMP BARRIER *** !!   if outone & ii are shared
!$OMP BARRIER
       else

!! (231) collecting first index,2

!$OMP DO SCHEDULE(STATIC) COLLAPSE(2)
          do i=1,blocksize
             do j=1,blocksize
                out(:,j,i,ii)=RESHAPE(outone(:,j,i,:),(/nprocs1*blocksize/))
             enddo
          enddo
!$OMP END DO
!! *** OMP BARRIER *** !!   if outone & ii are shared
!$OMP BARRIER
        
       endif
    enddo
!$OMP END PARALLEL

    call myclock(btime); times(3)=times(3)+btime-atime;

  end subroutine mytranspose_complex


  subroutine myzfft3d_par_forward(in,out,dim,times,howmany)
    use pmpimod
    implicit none
    integer, intent(in) :: dim,howmany
    complex*16, intent(in) :: in(*)
    complex*16, intent(out) :: out(*)
    integer, intent(inout) :: times(8)
    select case(orbparlevel)
    case(3)
       call myzfft3d_par0(in,out,dim,times,howmany,nprocs,1,1,orbparlevel)
    case(2)
       call myzfft3d_par0(in,out,dim,times,howmany,sqnprocs,sqnprocs,1,orbparlevel)
    case default
       print *, "ORBPARLEVEL NOT SUP", orbparlevel; call mpistop()
    end select
  end subroutine myzfft3d_par_forward

  subroutine myzfft3d_par_backward(in,out,dim,times,howmany)
    use pmpimod
    implicit none
    integer, intent(in) :: dim,howmany
    complex*16, intent(in) :: in(*)
    complex*16, intent(out) :: out(*)
    integer, intent(inout) :: times(8)
    select case(orbparlevel)
    case(3)
       call myzfft3d_par0(in,out,dim,times,howmany,nprocs,1,-1,orbparlevel)
    case (2)
       call myzfft3d_par0(in,out,dim,times,howmany,sqnprocs,sqnprocs,-1,orbparlevel)
    case default
       print *,  "ORBPARLEVEL NOT SUP", orbparlevel; call mpistop()
    end select

  end subroutine myzfft3d_par_backward


!!! adds to times

!!! times(1) = copy  times(2) = conjg  times(3) = ft
!!! from mytranspose times(4) = transpose   times(5) = mpi  times(6) = copy

  subroutine myzfft3d_par0(in,out,dim,times,howmany,nprocs1,nprocs2,direction,oplevel)
    use fft1dsubmod
    implicit none
    integer, intent(in) :: dim,howmany,nprocs1,nprocs2,direction,oplevel
    complex*16, intent(in) :: in(dim**3/nprocs1/nprocs2,howmany)
    complex*16, intent(out) :: out(dim**3/nprocs1/nprocs2,howmany)
    integer, intent(inout) :: times(8)
    integer :: ii,atime,btime
    complex*16 :: mywork(dim**3/nprocs1/nprocs2,howmany) !! AUTOMATIC

    mywork=0

    if (oplevel.ne.2.and.oplevel.ne.3) then
       print *, "OPLEVEL NOT SUP",oplevel; call mpistop()
    endif

    call myclock(atime)
    select case(direction)
    case(-1)
       out(:,:)=CONJG(in(:,:))
       call myclock(btime); times(2)=times(2)+btime-atime;
    case(1)
       out(:,:)=in(:,:)
       call myclock(btime); times(1)=times(1)+btime-atime;
    case default
       print *, "ACK PAR0 DIRECTION=",direction; call mpistop()
    end select

    do ii=1,3
       call myclock(atime)
       call myzfft1d( out, mywork, dim, dim**2/nprocs1/nprocs2*howmany)
       call myclock(btime); times(3)=times(3)+btime-atime
     
!!! from mytranspose times(4) = transpose   times(5) = mpi  times(6) = copy

       select case(oplevel)
       case(3)
          call mytranspose_complex(&
               mywork,  &
               out,  &
               dim/nprocs1, &
               howmany,times(4:),nprocs1,nprocs1)
       case(2)
          call mytranspose_complex(&
               mywork,  &
               out,  &
               dim/nprocs1, &
               howmany,times(4:),nprocs1,1)
       case default
          print *, "NOOOT SUP", oplevel; call mpistop()
       end select
    enddo

    call myclock(atime)
    select case(direction)
    case(-1)
       out(:,:)=CONJG(out(:,:))
       call myclock(btime); times(2)=times(2)+btime-atime
    case(1)
    case default
       print *, "ACK PAR0 DIRECTION=",direction; call mpistop()
    end select

  end subroutine myzfft3d_par0

end module fftparsubmod

#endif



module circ3dsubmod
  use clockmod

contains

subroutine circ3d_sub_real(rbigcirc,rmultvector,rffback,totdim,howmany)
  implicit none
  integer,intent(in) :: totdim,howmany
  real*8,intent(in) :: rmultvector(2*totdim,2*totdim,2*totdim,howmany), &
       rbigcirc(2*totdim,2*totdim,2*totdim)
  real*8,intent(out) :: rffback(2*totdim,2*totdim,2*totdim,howmany)
  complex*16 :: multvector(2*totdim,2*totdim,2*totdim,howmany), &              !! AUTOMATIC
       ffback(2*totdim,2*totdim,2*totdim,howmany),   bigcirc(2*totdim,2*totdim,2*totdim)

  ffback=0
  bigcirc(:,:,:)=rbigcirc(:,:,:)
  multvector(:,:,:,:)=rmultvector(:,:,:,:)
  call circ3d_sub(bigcirc,multvector,ffback,totdim,howmany)
  rffback(:,:,:,:)=real(ffback(:,:,:,:),8)

end subroutine circ3d_sub_real


subroutine circ3d_sub(bigcirc,multvector,ffback,totdim,howmany)
  use fft3dsubmod
  implicit none
  integer,intent(in) :: totdim,howmany
  complex*16,intent(in) ::  bigcirc(2*totdim,2*totdim,2*totdim,1,1,1), &
       multvector(2*totdim,2*totdim,2*totdim,howmany)
  complex*16,intent(out) :: ffback(2*totdim,2*totdim,2*totdim,howmany)
  complex*16 :: ffmat(2*totdim,2*totdim,2*totdim),ffvec(2*totdim,2*totdim,2*totdim,howmany),& 
       ffprod(2*totdim,2*totdim,2*totdim,howmany)                            !! AUTOMATIC
  integer :: ii

  ffvec=0; ffmat=0
  call myzfft3d(multvector(:,:,:,:),ffvec(:,:,:,:),2*totdim,2*totdim,2*totdim,howmany)
  call myzfft3d(bigcirc(:,:,:,1,1,1),ffmat(:,:,:),2*totdim,2*totdim,2*totdim,1)

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii)  
!$OMP DO SCHEDULE(STATIC)
  do ii=1,howmany
     ffprod(:,:,:,ii)=ffvec(:,:,:,ii)*ffmat(:,:,:)/(2*totdim)**3
  enddo
!$OMP END DO
!$OMP END PARALLEL

  ffprod(:,:,:,:)=CONJG(ffprod(:,:,:,:))
  call myzfft3d(ffprod(:,:,:,:),ffback(:,:,:,:),2*totdim,2*totdim,2*totdim,howmany)
  ffback(:,:,:,:)=CONJG(ffback(:,:,:,:))
  return

end subroutine circ3d_sub


#ifdef MPIFLAG

subroutine circ3d_sub_real_mpi(rbigcirc,rmultvector,rffback,dim1,dim2,dim3,times,howmany,placeopt)
  implicit none
  integer,intent(in) :: dim1,dim2,dim3,howmany,placeopt
  integer,intent(inout) :: times(*)
  integer :: atime,btime
  real*8,intent(in) :: rmultvector(2*dim1,2*dim2,2*dim3,howmany),   rbigcirc(2*dim1,2*dim2,2*dim3)
  real*8,intent(out) :: rffback(2*dim1,2*dim2,2*dim3,howmany)
  complex*16 :: multvector(2*dim1,2*dim2,2*dim3,howmany), &                    !! AUTOMATIC
        ffback(2*dim1,2*dim2,2*dim3,howmany),  bigcirc(2*dim1,2*dim2,2*dim3)

  call myclock(atime)
  ffback=0
  bigcirc(:,:,:)=rbigcirc(:,:,:)
  multvector(:,:,:,:)=rmultvector(:,:,:,:)
  call myclock(btime); times(7)=times(7)+btime-atime

  call circ3d_sub_mpi(bigcirc,multvector,ffback,dim1,dim2,dim3,times,howmany,placeopt)

  call myclock(atime)
  rffback(:,:,:,:)=real(ffback(:,:,:,:),8)
  call myclock(btime); times(7)=times(7)+btime-atime

end subroutine circ3d_sub_real_mpi


!!! times(7) = circ math

!!! from myzfft3d_par (if fft_mpi_inplaceopt == 1):

!!! times(1) = copy  times(2) = conjg  times(3) = ft
!!! from mytranspose times(4) = transpose   times(5) = mpi  times(6) = copy

!!! from cooleytukey (if fft_mpi_inplaceopt == 0):

!!! times(1) conjugate
!!! times(2) gettwiddle
!!! times(3) 1d ft-slowindex
!!! times(4) raise twiddle factor to power
!!! times(5) multiply
!!! times(6) 3d f.t.

subroutine circ3d_sub_mpi(bigcirc,multvector,ffback,dim1,dim2,dim3,times,howmany,placeopt)
  use fftparsubmod
  use cooleytukey2mod
  implicit none
  integer,intent(in) :: dim1,dim2,dim3,howmany,placeopt
  integer,intent(inout) :: times(*)
  complex*16,intent(in) ::  multvector(2*dim1,2*dim2,2*dim3,howmany), bigcirc(2*dim1,2*dim2,2*dim3,1,1,1)
  complex*16,intent(out) :: ffback(2*dim1,2*dim2,2*dim3,howmany)
  integer :: ii
  integer :: atime,btime,myrank,nprocs
  complex*16 :: ffmat(2*dim1,2*dim2,2*dim3), &                                     !! AUTOMATIC
       ffvec(2*dim1,2*dim2,2*dim3,howmany),  ffprod(2*dim1,2*dim2,2*dim3,howmany)

  ffvec=0; ffmat=0

  call getmyranknprocs(myrank,nprocs)  

  if (placeopt.ne.1) then
     call ct2_outofplace_forward_mpi_3d(multvector(:,:,:,:),ffvec(:,:,:,:),2*dim1,2*dim2,2*dim3,howmany)
     call ct2_outofplace_forward_mpi_3d(bigcirc(:,:,:,1,1,1),ffmat(:,:,:),2*dim1,2*dim2,2*dim3,1)
  else
     call myzfft3d_par_forward(multvector(:,:,:,:),ffvec(:,:,:,:),2*dim1,times,howmany)
     call myzfft3d_par_forward(bigcirc(:,:,:,1,1,1),ffmat(:,:,:),2*dim1,times,1)
  endif

  call myclock(atime)

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(ii)
!$OMP DO SCHEDULE(STATIC)
  do ii=1,howmany
     ffprod(:,:,:,ii)=ffvec(:,:,:,ii)*ffmat(:,:,:)/(8*dim1*dim2*dim3*nprocs)
  enddo
!$OMP END DO
!$OMP END PARALLEL

  call myclock(btime); times(7)=times(7)+btime-atime

  if (placeopt.ne.1) then
     call ct2_outofplace_backward_mpi_3d(ffprod(:,:,:,:),ffback(:,:,:,:),2*dim1,2*dim2,2*dim3,howmany)
  else
     call myzfft3d_par_backward(ffprod(:,:,:,:),ffback(:,:,:,:),2*dim1,times,howmany)
  endif

end subroutine circ3d_sub_mpi

#endif

end module circ3dsubmod


