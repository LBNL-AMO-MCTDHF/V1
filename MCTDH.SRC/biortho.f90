!! ALL MODULES
!!$
!!$Apache License
!!$                           Version 2.0, January 2004
!!$                        http://www.apache.org/licenses/
!!$
!!$   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
!!$
!!$   1. Definitions.
!!$
!!$      "License" shall mean the terms and conditions for use, reproduction,
!!$      and distribution as defined by Sections 1 through 9 of this document.
!!$
!!$      "Licensor" shall mean the copyright owner or entity authorized by
!!$      the copyright owner that is granting the License.
!!$
!!$      "Legal Entity" shall mean the union of the acting entity and all
!!$      other entities that control, are controlled by, or are under common
!!$      control with that entity. For the purposes of this definition,
!!$      "control" means (i) the power, direct or indirect, to cause the
!!$      direction or management of such entity, whether by contract or
!!$      otherwise, or (ii) ownership of fifty percent (50%) or more of the
!!$      outstanding shares, or (iii) beneficial ownership of such entity.
!!$
!!$      "You" (or "Your") shall mean an individual or Legal Entity
!!$      exercising permissions granted by this License.
!!$
!!$      "Source" form shall mean the preferred form for making modifications,
!!$      including but not limited to software source code, documentation
!!$      source, and configuration files.
!!$
!!$      "Object" form shall mean any form resulting from mechanical
!!$      transformation or translation of a Source form, including but
!!$      not limited to compiled object code, generated documentation,
!!$      and conversions to other media types.
!!$
!!$      "Work" shall mean the work of authorship, whether in Source or
!!$      Object form, made available under the License, as indicated by a
!!$      copyright notice that is included in or attached to the work
!!$      (an example is provided in the Appendix below).
!!$
!!$      "Derivative Works" shall mean any work, whether in Source or Object
!!$      form, that is based on (or derived from) the Work and for which the
!!$      editorial revisions, annotations, elaborations, or other modifications
!!$      represent, as a whole, an original work of authorship. For the purposes
!!$      of this License, Derivative Works shall not include works that remain
!!$      separable from, or merely link (or bind by name) to the interfaces of,
!!$      the Work and Derivative Works thereof.
!!$
!!$      "Contribution" shall mean any work of authorship, including
!!$      the original version of the Work and any modifications or additions
!!$      to that Work or Derivative Works thereof, that is intentionally
!!$      submitted to Licensor for inclusion in the Work by the copyright owner
!!$      or by an individual or Legal Entity authorized to submit on behalf of
!!$      the copyright owner. For the purposes of this definition, "submitted"
!!$      means any form of electronic, verbal, or written communication sent
!!$      to the Licensor or its representatives, including but not limited to
!!$      communication on electronic mailing lists, source code control systems,
!!$      and issue tracking systems that are managed by, or on behalf of, the
!!$      Licensor for the purpose of discussing and improving the Work, but
!!$      excluding communication that is conspicuously marked or otherwise
!!$      designated in writing by the copyright owner as "Not a Contribution."
!!$
!!$      "Contributor" shall mean Licensor and any individual or Legal Entity
!!$      on behalf of whom a Contribution has been received by Licensor and
!!$      subsequently incorporated within the Work.
!!$
!!$   2. Grant of Copyright License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      copyright license to reproduce, prepare Derivative Works of,
!!$      publicly display, publicly perform, sublicense, and distribute the
!!$      Work and such Derivative Works in Source or Object form.
!!$
!!$   3. Grant of Patent License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      (except as stated in this section) patent license to make, have made,
!!$      use, offer to sell, sell, import, and otherwise transfer the Work,
!!$      where such license applies only to those patent claims licensable
!!$      by such Contributor that are necessarily infringed by their
!!$      Contribution(s) alone or by combination of their Contribution(s)
!!$      with the Work to which such Contribution(s) was submitted. If You
!!$      institute patent litigation against any entity (including a
!!$      cross-claim or counterclaim in a lawsuit) alleging that the Work
!!$      or a Contribution incorporated within the Work constitutes direct
!!$      or contributory patent infringement, then any patent licenses
!!$      granted to You under this License for that Work shall terminate
!!$      as of the date such litigation is filed.
!!$
!!$   4. Redistribution. You may reproduce and distribute copies of the
!!$      Work or Derivative Works thereof in any medium, with or without
!!$      modifications, and in Source or Object form, provided that You
!!$      meet the following conditions:
!!$
!!$      (a) You must give any other recipients of the Work or
!!$          Derivative Works a copy of this License; and
!!$
!!$      (b) You must cause any modified files to carry prominent notices
!!$          stating that You changed the files; and
!!$
!!$      (c) You must retain, in the Source form of any Derivative Works
!!$          that You distribute, all copyright, patent, trademark, and
!!$          attribution notices from the Source form of the Work,
!!$          excluding those notices that do not pertain to any part of
!!$          the Derivative Works; and
!!$
!!$      (d) If the Work includes a "NOTICE" text file as part of its
!!$          distribution, then any Derivative Works that You distribute must
!!$          include a readable copy of the attribution notices contained
!!$          within such NOTICE file, excluding those notices that do not
!!$          pertain to any part of the Derivative Works, in at least one
!!$          of the following places: within a NOTICE text file distributed
!!$          as part of the Derivative Works; within the Source form or
!!$          documentation, if provided along with the Derivative Works; or,
!!$          within a display generated by the Derivative Works, if and
!!$          wherever such third-party notices normally appear. The contents
!!$          of the NOTICE file are for informational purposes only and
!!$          do not modify the License. You may add Your own attribution
!!$          notices within Derivative Works that You distribute, alongside
!!$          or as an addendum to the NOTICE text from the Work, provided
!!$          that such additional attribution notices cannot be construed
!!$          as modifying the License.
!!$
!!$      You may add Your own copyright statement to Your modifications and
!!$      may provide additional or different license terms and conditions
!!$      for use, reproduction, or distribution of Your modifications, or
!!$      for any such Derivative Works as a whole, provided Your use,
!!$      reproduction, and distribution of the Work otherwise complies with
!!$      the conditions stated in this License.
!!$
!!$   5. Submission of Contributions. Unless You explicitly state otherwise,
!!$      any Contribution intentionally submitted for inclusion in the Work
!!$      by You to the Licensor shall be under the terms and conditions of
!!$      this License, without any additional terms or conditions.
!!$      Notwithstanding the above, nothing herein shall supersede or modify
!!$      the terms of any separate license agreement you may have executed
!!$      with Licensor regarding such Contributions.
!!$
!!$   6. Trademarks. This License does not grant permission to use the trade
!!$      names, trademarks, service marks, or product names of the Licensor,
!!$      except as required for reasonable and customary use in describing the
!!$      origin of the Work and reproducing the content of the NOTICE file.
!!$
!!$   7. Disclaimer of Warranty. Unless required by applicable law or
!!$      agreed to in writing, Licensor provides the Work (and each
!!$      Contributor provides its Contributions) on an "AS IS" BASIS,
!!$      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
!!$      implied, including, without limitation, any warranties or conditions
!!$      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
!!$      PARTICULAR PURPOSE. You are solely responsible for determining the
!!$      appropriateness of using or redistributing the Work and assume any
!!$      risks associated with Your exercise of permissions under this License.
!!$
!!$   8. Limitation of Liability. In no event and under no legal theory,
!!$      whether in tort (including negligence), contract, or otherwise,
!!$      unless required by applicable law (such as deliberate and grossly
!!$      negligent acts) or agreed to in writing, shall any Contributor be
!!$      liable to You for damages, including any direct, indirect, special,
!!$      incidental, or consequential damages of any character arising as a
!!$      result of this License or out of the use or inability to use the
!!$      Work (including but not limited to damages for loss of goodwill,
!!$      work stoppage, computer failure or malfunction, or any and all
!!$      other commercial damages or losses), even if such Contributor
!!$      has been advised of the possibility of such damages.
!!$
!!$   9. Accepting Warranty or Additional Liability. While redistributing
!!$      the Work or Derivative Works thereof, You may choose to offer,
!!$      and charge a fee for, acceptance of support, warranty, indemnity,
!!$      or other liability obligations and/or rights consistent with this
!!$      License. However, in accepting such obligations, You may act only
!!$      on Your own behalf and on Your sole responsibility, not on behalf
!!$      of any other Contributor, and only if You agree to indemnify,
!!$      defend, and hold each Contributor harmless for any liability
!!$      incurred by, or claims asserted against, such Contributor by reason
!!$      of your accepting any such warranty or additional liability.
!!$
!!$   END OF TERMS AND CONDITIONS
!!$
!!$   Copyright 2016 the regents of the University of California
!!$
!!$   Licensed under the Apache License, Version 2.0 (the "License");
!!$   you may not use this file except in compliance with the License.
!!$   You may obtain a copy of the License at
!!$
!!$       http://www.apache.org/licenses/LICENSE-2.0
!!$
!!$   Unless required by applicable law or agreed to in writing, software
!!$   distributed under the License is distributed on an "AS IS" BASIS,
!!$   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!$   See the License for the specific language governing permissions and
!!$   limitations under the License.


!! BIORTHOGONALZATION ROUTINES


#include "Definitions.INC"

!! this is the bad boy that does biorthonormalization
!! it gets fed in all the parameters it way need to eschew parameters and the mods
!! pointers are used to save on memory slightly for the external routine needed in expokit 
!! and the sparse algorithm     they are instanced only once for the call to 
!! abio_sparse and then dropped so we don't leave any unwanted dangling pointers
!! the main thing is verifying that biortho's self-re-initializer is functioning properly
!! it should be for all electron flux subroutine needs, but in case of added functionality 
!! that uses this routine double check this    kvl

module biorthotypemod
  use walkmod
  type biorthotype
     type(walktype),pointer :: wwbio
     DATATYPE, pointer :: smo(:,:)
     integer :: thisbiodim=100000000, biomaxdim=-1, bionr=-1
     logical :: started=.false.
     real*8 :: tempstepsize=-1d0
     integer :: icalled=0
     logical :: hermonly=.false.
  end type biorthotype
end module biorthotypemod

module biomatvecmod
  use biorthotypemod
  implicit none
  type(biorthotype), pointer :: biopointer
end module

module matvecsetmod
contains
subroutine biomatvecset(inbiotarget)
  use biomatvecmod
  implicit none
  type(biorthotype), target :: inbiotarget
  biopointer=>inbiotarget
end subroutine biomatvecset
end module matvecsetmod


module abiosparsemod
contains

!! this is the sparse specific routine that does the back-transofrmation of the a-vector

!! the external subroutine
!! does y=-ln(S)*x for the formation of the Krylov vectors
!! input:
!! x - previous krylov vector
!! output:
!! y - the  krylov vector y = -ln(S)x
!! data needed from biorthomod:
!! Smo - the overlap matrix containing -ln(s)
!! the config and walk mod objects are pointers to the configlist and singlewalk arrays 
!! that were passed to biortho when it was called this time

  subroutine biomatvec_byproc(firstproc,lastproc,x,y)
    use mpimod !! myrank
    use biomatvecmod
    implicit none
    integer,intent(in) :: firstproc,lastproc
    integer :: i,j,ihop,phase
    DATATYPE,intent(in) :: x(biopointer%bionr,biopointer%wwbio%allbotconfigs(firstproc):&
         biopointer%wwbio%alltopconfigs(lastproc))
    DATATYPE,intent(out) :: y(biopointer%bionr,biopointer%wwbio%botconfig:&
         biopointer%wwbio%topconfig)
    DATATYPE :: csum,myout(biopointer%bionr), holetrace

    phase=1
    if (biopointer%wwbio%topconfig.ge.biopointer%wwbio%botconfig) then
       if (biopointer%wwbio%holeflag.eq.0) then
          y(:,:)=0d0
       else
          phase=(-1)
          holetrace=0d0
          do i=1,biopointer%wwbio%nspf
             holetrace=holetrace + biopointer%smo(i,i) * 2
          enddo
          if (firstproc.le.myrank.and.lastproc.ge.myrank) then
             do i=biopointer%wwbio%botconfig,biopointer%wwbio%topconfig
                if (biopointer%wwbio%singlehopdiagflag(i).ne.0) then
                   y(:,i) = holetrace * x(:,i)
                endif
             enddo
          endif
       endif
    endif

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(i,ihop,csum,j,myout) 

!$OMP DO SCHEDULE(DYNAMIC)
    do i=biopointer%wwbio%botconfig,biopointer%wwbio%topconfig
!! summing over nonconjugated second index in s(:), good

       myout(:)=y(:,i)
       do ihop=biopointer%wwbio%firstsinglehopbyproc(firstproc,i), &
            biopointer%wwbio%lastsinglehopbyproc(lastproc,i) 
          csum=0d0
          do j=biopointer%wwbio%singlehopwalkstart(ihop,i), &
               biopointer%wwbio%singlehopwalkend(ihop,i)
             csum=csum + &
                  biopointer%smo(biopointer%wwbio%singlewalkopspf(1,j+biopointer%wwbio%scol(i)),&
                  biopointer%wwbio%singlewalkopspf(2,j+biopointer%wwbio%scol(i))) &
                  * biopointer%wwbio%singlewalkdirphase(j+biopointer%wwbio%scol(i))
          enddo
          myout(:) = myout(:) + csum * x(:,biopointer%wwbio%singlehop(ihop,i)) * phase
       enddo
       y(:,i)=myout(:)
    enddo
!$OMP END DO
!$OMP END PARALLEL

  end subroutine biomatvec_byproc

  subroutine parbiomatvec_gather(inavector,outavector)
    use fileptrmod
    use mpimod
    use matvecsetmod
    use biomatvecmod
    use basissubmod
    use mpisubmod
    implicit none
    DATATYPE,intent(in) :: inavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE,intent(out) :: outavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE,allocatable :: intemp(:,:)
!! AUTOMATIC
    DATATYPE :: outtemp(biopointer%bionr,biopointer%wwbio%botconfig:biopointer%wwbio%topconfig+1)

    if (biopointer%wwbio%sparseconfigflag.eq.0) then
       OFLWR "error, must use sparse for parbiomatvec summa"; CFLST
    endif

    allocate(intemp(biopointer%bionr,biopointer%wwbio%numconfig));  intemp(:,:)=0d0;  outtemp=0

!! transform second to reduce communication?
!!   no, spin transformations done locally now.

    if (biopointer%wwbio%topdfbasis.ge.biopointer%wwbio%botdfbasis) then
       call basis_transformfrom_local(biopointer%wwbio,biopointer%bionr,inavector,&
            intemp(:,biopointer%wwbio%botconfig:biopointer%wwbio%topconfig))
    endif

    call mpiallgather_local(intemp,biopointer%wwbio%numconfig*biopointer%bionr,&
         biopointer%wwbio%nzconfsperproc(:)*biopointer%bionr,&
         biopointer%wwbio%maxconfigsperproc*biopointer%bionr,&
         biopointer%wwbio%NZ_COMM,biopointer%wwbio%nzprocs,&
         biopointer%wwbio%nzrank)

    if (biopointer%wwbio%topconfig.ge.biopointer%wwbio%botconfig) then
       call biomatvec_byproc(1,nprocs,intemp,outtemp)
    endif

    outavector(:,:)=0d0   !! PADDED

    if (biopointer%wwbio%topdfbasis.ge.biopointer%wwbio%botdfbasis) then
       call basis_transformto_local(biopointer%wwbio,biopointer%bionr,outtemp,outavector)
    endif

    deallocate(intemp)

  end subroutine parbiomatvec_gather

#ifdef MPIFLAG

  subroutine parbiomatvec_summa(inavector,outavector)
    use fileptrmod
    use mpimod   !! myrank
    use matvecsetmod
    use biomatvecmod
    use basissubmod
    use mpisubmod
    implicit none
    DATATYPE,intent(in) :: inavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE,intent(out) :: outavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE :: intemp(biopointer%bionr,biopointer%wwbio%maxconfigsperproc),&   !!AUTOMATIC
         outwork(biopointer%bionr,biopointer%wwbio%botconfig:biopointer%wwbio%topconfig+1),&
         outtemp(biopointer%bionr,biopointer%wwbio%botconfig:biopointer%wwbio%topconfig+1)
    integer :: iproc,iiproc

    if (biopointer%wwbio%sparseconfigflag.eq.0) then
       OFLWR "error, must use sparse for parbiomatvec summa"; CFLST
    endif

    outwork=0d0; outtemp=0; intemp=0

    do iiproc=1,biopointer%wwbio%nzprocs

       iproc=biopointer%wwbio%nzproclist(iiproc)

!! transform second to reduce communication?
!!   no, spin transformations done locally now.

       if(biopointer%wwbio%alltopconfigs(iproc).ge.biopointer%wwbio%allbotconfigs(iproc)) then
          if (myrank.eq.iproc) then
             intemp=0
             if (biopointer%wwbio%topdfbasis.ge.biopointer%wwbio%botdfbasis) then
                call basis_transformfrom_local(biopointer%wwbio,biopointer%bionr,&
                     inavector(:,:),intemp(:,:))
             endif
          endif

          call mympibcast_local(intemp,iiproc,&
               biopointer%wwbio%nzconfsperproc(iiproc)*biopointer%bionr,&
               biopointer%wwbio%NZ_COMM)

          call biomatvec_byproc(iproc,iproc,intemp,outtemp)

          outwork(:,:)=outwork(:,:)+outtemp(:,:)

       endif
    enddo

    outavector(:,:)=0d0   !! PADDED

    if (biopointer%wwbio%topdfbasis.ge.biopointer%wwbio%botdfbasis) then
       call basis_transformto_local(biopointer%wwbio,biopointer%bionr,&
            outwork(:,:),outavector(:,:))
    endif

  end subroutine parbiomatvec_summa

  subroutine parbiomatvec_circ(inavector,outavector)
    use fileptrmod
    use matvecsetmod
    use biomatvecmod
    use basissubmod
    use mpisubmod
    implicit none
    DATATYPE,intent(in) :: inavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE,intent(out) :: outavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE :: workvector(biopointer%bionr,biopointer%wwbio%maxconfigsperproc),&
         workvector2(biopointer%bionr,biopointer%wwbio%maxconfigsperproc),&    !!AUTOMATIC
         outwork(biopointer%bionr,biopointer%wwbio%botconfig:biopointer%wwbio%topconfig+1),&
         outtemp(biopointer%bionr,biopointer%wwbio%botconfig:biopointer%wwbio%topconfig+1)
    integer :: iproc,prevproc,nextproc,deltaproc,iiproc

    if (biopointer%wwbio%sparseconfigflag.eq.0) then
       OFLWR "error, must use sparse for parbiomatvec summa"; CFLST
    endif

!! doing circ mult slightly different than e.g. SINCDVR/coreproject.f90 
!!     and ftcore.f90, holding hands in a circle, prevproc and nextproc, 
!!     each chunk gets passed around the circle

    prevproc=mod(biopointer%wwbio%nzprocs+biopointer%wwbio%nzrank-2,&
         biopointer%wwbio%nzprocs)+1
    nextproc=mod(biopointer%wwbio%nzrank,biopointer%wwbio%nzprocs)+1

    workvector=0; workvector2=0; outwork=0; outtemp=0

    if (biopointer%wwbio%topdfbasis.ge.biopointer%wwbio%botdfbasis) then
       call basis_transformfrom_local(biopointer%wwbio,biopointer%bionr,&
            inavector(:,:),workvector(:,:))
    endif

    do deltaproc=0,biopointer%wwbio%nzprocs-1

!! PASSING BACKWARD (plus deltaproc)
       iiproc=mod(biopointer%wwbio%nzrank-1+deltaproc,&
            biopointer%wwbio%nzprocs)+1
       iproc=biopointer%wwbio%nzproclist(iiproc)

       if (biopointer%wwbio%alltopconfigs(iproc).ge.biopointer%wwbio%allbotconfigs(iproc).and.&
            biopointer%wwbio%topconfig.ge.biopointer%wwbio%botconfig) then
          call biomatvec_byproc(iproc,iproc,workvector,outtemp)
          outwork(:,:)=outwork(:,:)+outtemp(:,:)
       endif

!! PASSING BACKWARD
!! mympisendrecv(sendbuf,recvbuf,dest,source,...)

       call mympisendrecv_local(workvector,workvector2,prevproc,nextproc,deltaproc,&
            biopointer%bionr * biopointer%wwbio%maxconfigsperproc,biopointer%wwbio%NZ_COMM)
       workvector(:,:)=workvector2(:,:)

    enddo

    outavector(:,:)=0d0   !! PADDED

    if (biopointer%wwbio%topdfbasis.ge.biopointer%wwbio%botdfbasis) then
       call basis_transformto_local(biopointer%wwbio,biopointer%bionr,&
            outwork(:,:),outavector(:,:))
    endif

  end subroutine parbiomatvec_circ

#endif

!! NOTE BOUNDS !! PADDED !!

  subroutine parbiomatvec(inavector,outavector)
    use fileptrmod
    use sparse_parameters   !! sparsesummaflag
    use biomatvecmod
    implicit none
    DATATYPE,intent(in) :: inavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)
    DATATYPE,intent(out) :: outavector(biopointer%bionr,biopointer%wwbio%maxdfbasisperproc)

#ifdef MPIFLAG
    select case (sparsesummaflag)
    case(0)
#endif
       call parbiomatvec_gather(inavector,outavector)

#ifdef MPIFLAG
    case(1)
       call parbiomatvec_summa(inavector,outavector)
    case(2)
       call parbiomatvec_circ(inavector,outavector)
    case default
       OFLWR "Error sparsesummaflag ",sparsesummaflag; CFLST
    end select
#endif

  end subroutine parbiomatvec


  subroutine abio_sparse(abio,aout,inbiovar)
    use fileptrmod
    use timing_parameters
    use sparse_parameters   !! nzflag
    use bio_parameters
    use mpimod        !! myrank
    use matvecsetmod
    use biorthotypemod
    use basissubmod
    use mpisubmod
    use expokitmod, only: dgexpvxxx2
    implicit none
    type(biorthotype),target,intent(inout) :: inbiovar
    DATATYPE,intent(in) :: abio(inbiovar%bionr,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig)
    DATATYPE,intent(out) :: aout(inbiovar%bionr,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig)
    integer, allocatable :: iwsp(:)
    integer*8, save :: icalledhere=0
    integer :: biofileptr=6719
    real*8 :: t,anorm, tol
    integer :: liwsp,lwsp,itrace,iflag,ixx,getlen,myiostat,minflag
    DATATYPE, allocatable :: smallvector(:,:), smallvectorout(:,:)
    real*8,allocatable :: wsp(:)

    if (inbiovar%wwbio%sparseconfigflag.eq.0) then
       OFLWR "Error, can't use abio_sparse if sparseconfigflag=0"; CFLST
    endif

    t=1d0;  anorm=1d0 ;  itrace=0;   iflag=0; tol=biotol;   
    icalledhere=icalledhere+1
    inbiovar%icalled=inbiovar%icalled+1

    if (inbiovar%icalled.eq.1) then
       inbiovar%tempstepsize=1d0
    endif

    if (inbiovar%thisbiodim.lt.inbiovar%biomaxdim) then
       inbiovar%tempstepsize=inbiovar%tempstepsize*4
    else
       inbiovar%tempstepsize=inbiovar%tempstepsize*1.1
    endif

    if ((myrank.eq.1).and.(notiming==0)) then
       if (icalledhere.eq.1) then
          open(biofileptr,file=timingdir(1:getlen(timingdir))//"/biortho.dat",&
               status="unknown",iostat=myiostat)
          call checkiostat(myiostat,"opening biortho timing file")
          write(biofileptr,*,iostat=myiostat) 
          call checkiostat(myiostat,"writing biortho timing file")
          write(biofileptr,*);        close(biofileptr)
       endif

!     open(biofileptr,file=timingdir(1:getlen(timingdir))//"/biortho.dat",status="old", &
!          position="append")
!     write(biofileptr,*) " BIORTHO. numr",inbiovar%bionr," biodim ",&
!          inbiovar%thisbiodim, "step ",min(1d0,inbiovar%tempstepsize)
!     close(biofileptr)
    endif

    if (myrank.eq.1.and.notiming.eq.0) then
       open(biofileptr,file=timingdir(1:getlen(timingdir))//"/biortho.dat",&
            status="old", position="append",iostat=myiostat)
       call checkiostat(myiostat,"opening biortho timing file")
    else
!!$ opening /dev/null multiple times not allowed :<      
!!$ open(biofileptr,file="/dev/null",status="unknown")

       biofileptr=nullfileptr
    endif

    call biomatvecset(inbiovar)

#ifdef REALGO
    ixx=inbiovar%wwbio%maxdfbasisperproc*inbiovar%bionr
#else
    ixx=inbiovar%wwbio%maxdfbasisperproc*inbiovar%bionr*2
#endif
    lwsp = ixx*(inbiovar%thisbiodim+4) + 6*(inbiovar%thisbiodim+3)**2 + 100

    liwsp = inbiovar%thisbiodim+100

    allocate(wsp(lwsp),iwsp(liwsp));  wsp=0; iwsp=0
    allocate(smallvector(inbiovar%bionr,inbiovar%wwbio%maxdfbasisperproc),&
         smallvectorout(inbiovar%bionr,inbiovar%wwbio%maxdfbasisperproc))
    smallvector(:,:)=0; smallvectorout(:,:)=0

    if (inbiovar%wwbio%topconfig.ge.inbiovar%wwbio%botconfig) then
       call basis_transformto_local(inbiovar%wwbio,inbiovar%bionr,&
            abio(:,inbiovar%wwbio%botconfig:inbiovar%wwbio%topconfig),smallvector(:,:))
    endif

    call mpibarrier()
    iflag=0
    if (nzflag.eq.0.or.inbiovar%wwbio%nzrank.gt.0) then
       call DGEXPVxxx2(ixx,inbiovar%thisbiodim,t,smallvector,smallvectorout,tol,anorm,wsp,&
            lwsp,iwsp,liwsp,parbiomatvec,itrace,iflag,biofileptr,&
            inbiovar%tempstepsize,realpardotsub,inbiovar%biomaxdim+1)
    else
       smallvectorout=0d0
    endif
    call mpibarrier()

    minflag=iflag
    call mympiimax(iflag)
    call mympiimin(minflag)

    if(iflag.eq.1.and.minflag.ge.0) then
       OFLWR "Solution did not converge in sparsebiortho but continuing";
       WRFL iflag,minflag,tol,inbiovar%thisbiodim; CFL
    elseif(iflag.ne.0.or.minflag.ne.0) then
       OFLWR "Stopping due to bad iflag in sparsebiortho: "
       WRFL iflag,minflag,tol,inbiovar%thisbiodim; CFLST
    endif
    if (inbiovar%wwbio%lastconfig.ge.inbiovar%wwbio%firstconfig) then
       aout(:,:)=0d0
    endif
    if (inbiovar%wwbio%topconfig.ge.inbiovar%wwbio%botconfig) then
       call basis_transformfrom_local(inbiovar%wwbio,inbiovar%bionr,&
            smallvectorout(:,:),aout(:,inbiovar%wwbio%botconfig:inbiovar%wwbio%topconfig))
    endif
    if (inbiovar%wwbio%parconsplit.eq.0) then
       call mpiallgather(aout,inbiovar%wwbio%numconfig*inbiovar%bionr,&
            inbiovar%wwbio%configsperproc(:)*inbiovar%bionr,&
            inbiovar%wwbio%maxconfigsperproc*inbiovar%bionr)
    endif
    deallocate(smallvector,smallvectorout)

    if (myrank.eq.1.and.notiming.eq.0) then
       open(biofileptr,file=timingdir(1:getlen(timingdir))//"/biortho.dat",&
            status="old", position="append",iostat=myiostat)
       call checkiostat(myiostat,"opening biortho timing file")

       write(biofileptr,*,iostat=myiostat) " Bio: steps, iter, stepsize", &
            iwsp(4),iwsp(1),inbiovar%tempstepsize; 
       call checkiostat(myiostat,"writing biortho timing file")
       if ((iwsp(4).gt.1)) then
          write(biofileptr,*) "Warning - biorthogonalization restarting. Ddim, tol: ", &
               inbiovar%thisbiodim, biotol; 
       endif
       close(biofileptr)
    endif

    if (mod(inbiovar%icalled,20)==0.and.iwsp(4).eq.1) then
       inbiovar%thisbiodim=max(min(4,inbiovar%biomaxdim),inbiovar%thisbiodim-1)
    endif
    if (iwsp(4).gt.1) then
       inbiovar%thisbiodim=min(inbiovar%thisbiodim+2, inbiovar%biomaxdim)
    endif
    if (iwsp(4).gt.5) then
       inbiovar%thisbiodim=min(inbiovar%thisbiodim*2,inbiovar%biomaxdim)
    endif
    deallocate(wsp,iwsp)

  contains
    subroutine realpardotsub(one,two,n,out)
      implicit none
      integer,intent(in) :: n
      real*8,intent(in) :: one(n),two(n)
      real*8,intent(out) :: out
      real*8 :: sum
      sum=DOT_PRODUCT(one,two)
      call mympirealreduceone_local(sum,inbiovar%wwbio%NZ_COMM)
      out=sum
    end subroutine realpardotsub

  end subroutine abio_sparse

end module abiosparsemod


!!!!!!!!!!!!!!!!!!!!!!!!!

!! these are the encapuslated routines necessary for bi-orthonoramlization as we've derived it
!! the program takes a ton of inputs so it needs not ever use a module other than it's own and mpi
!! the code is also set to be self-resetting if a sour input is passed to it
!! right now if the number of configurations or electrons changes it resets, 
!! this is because the only variables not instanced just once are the spin config lists 
!! (alpha, beta, etc) that are needed for nonsparse routines, and the depend on the number of 
!! congigs and electrons the sparse algorithm needs no lingering variables as everything is 
!! passed and pointed to for just the duration of the call to biortho
!! xoxo -KVL 

!! all the global variables needed to do biothonormalization without any mod save this one and mpi
!! this mod is also NOT in main_modules because we do not want these variables to be touchable 
!! by any other routines than the ones in this file if we can avoid it

module biorthomod
  use mpisubmod

contains
  subroutine bioset(biotypevar,insmo,innumr,wwbio)
    use bio_parameters
    use tol_parameters
    use biorthotypemod
    use mpimod   !! nprocs
    implicit none
    integer,intent(in) :: innumr
    type(walktype),target,intent(in) :: wwbio
    Type(biorthotype),target,intent(inout) :: biotypevar
    DATATYPE,target :: insmo(wwbio%nspf,wwbio%nspf)
#ifdef REALGO
    integer,parameter :: zzz=1
#else
    integer,parameter :: zzz=2
#endif

    biotypevar%wwbio=>wwbio
    biotypevar%smo=>insmo
    biotypevar%bionr=innumr

!!$    biotypevar%biomaxdim=min(maxbiodim*zzz,biotypevar%wwbio%maxdfbasisperproc*biotypevar%bionr*zzz*nprocs-1)

    biotypevar%biomaxdim=max(1,min(maxbiodim*zzz,zzz*biotypevar%wwbio%numdfbasis*biotypevar%bionr-1))

    if (.not.biotypevar%started) then
       biotypevar%thisbiodim=min(biodim,biotypevar%biomaxdim)
    endif
    biotypevar%started=.true.

  end subroutine bioset


!! this is the non-sparse specific routine that does the back-transofrmation of the a-vector
  subroutine abio_nonsparse(abio,aout,inbiovar)
    use fileptrmod
    use mpimod     !! myrank,nprocs
    use aarrmod
    use biorthotypemod
    use tol_parameters
    use configsubmod
    implicit none
    Type(biorthotype),target,intent(inout) :: inbiovar
    DATATYPE,intent(in) :: abio(inbiovar%bionr,inbiovar%wwbio%numconfig)
    DATATYPE,intent(out) :: aout(inbiovar%bionr,inbiovar%wwbio%numconfig)
    integer :: i,j,iflag,clow,chigh,jproc,cnum,nnn(2),mmm(2),rank,lwork,&
         flag,k,l
    integer,allocatable :: bioconfiglist(:,:), bioeleclist(:,:)
    DATATYPE,allocatable :: smobig(:,:), Stmpbig(:,:), Sconfig(:,:),&
         aouttr(:,:), work(:)
    real*8,allocatable :: sing(:),rwork(:)

    lwork=10 * ( inbiovar%wwbio%numconfig + inbiovar%bionr )

    allocate( bioconfiglist(inbiovar%wwbio%numpart+1,inbiovar%wwbio%numconfig), &  !! PADDED
         bioeleclist(inbiovar%wwbio%numelec+1,inbiovar%wwbio%numconfig), &          !! PADDED
         smobig(inbiovar%wwbio%nspf*2,inbiovar%wwbio%nspf*2),&
         Stmpbig(inbiovar%wwbio%numelec,inbiovar%wwbio%numelec), &
         Sconfig(inbiovar%wwbio%numconfig,inbiovar%wwbio%numconfig), &
         aouttr(inbiovar%wwbio%numconfig,inbiovar%bionr),&
         work(lwork), &
         sing(inbiovar%wwbio%numconfig),rwork(5*inbiovar%wwbio%numconfig) )
    bioconfiglist=0; bioeleclist=0; smobig=0d0; stmpbig=0; sconfig=0; aouttr=0;  
    sing=0; rwork=0; work=0

!! for the nonsparse routine this builds the full nonsparse configuration overlap matrix
!! this relies on the unique properties of the Doolittle algorithm of LU factorization
!! to take the overlap matrices of the ith and jth configs alpha and beta orbitals and 
!! get their determinant that way this is very much so a brute force way to approach 
!! this problem

    do i=1,inbiovar%wwbio%nspf*2
       mmm(:)=aarr(i)
       do j=1,inbiovar%wwbio%nspf*2
          nnn(:)=aarr(j)
          if (mmm(2).eq.nnn(2)) then
             smobig(i,j)=inbiovar%smo(mmm(1),nnn(1))
          endif
       enddo
    enddo

    do i=1,inbiovar%wwbio%numconfig
       do j=1,inbiovar%wwbio%numpart
          bioconfiglist(j,i)=iind( inbiovar%wwbio%configlist(j*2-1:j*2,i) )
       enddo
    enddo
    if (inbiovar%wwbio%holeflag.eq.0) then
       bioeleclist(:,:)=bioconfiglist(:,:)
    else
       do i=1,inbiovar%wwbio%numconfig
          k=0
          do j=1,2*inbiovar%wwbio%nspf
             flag=0
             do l=1,inbiovar%wwbio%numpart
                if (bioconfiglist(l,i).eq.j) then
                   flag=1
                   exit
                endif
             enddo
             if (flag.eq.0) then
                k=k+1
                bioeleclist(k,i)=j
             endif
          enddo
          if (k.ne.inbiovar%wwbio%numelec) then
             print *, "EEEEEROR12345 ",k,inbiovar%wwbio%numelec; stop
          endif
       enddo
    endif

    do j=inbiovar%wwbio%botconfig,inbiovar%wwbio%topconfig
       do i=1,inbiovar%wwbio%numconfig

          call get_petite_mat(inbiovar%wwbio%nspf*2,inbiovar%wwbio%numelec,Smobig,&
               Stmpbig,bioeleclist(:,i),bioeleclist(:,j))

          sconfig(i,j) = matdet(inbiovar%wwbio%numelec,Stmpbig)

       enddo
    enddo

    call mpiallgather(sconfig,inbiovar%wwbio%numconfig**2,&
         inbiovar%wwbio%configsperproc(:)*inbiovar%wwbio%numconfig,&
         inbiovar%wwbio%maxconfigsperproc*inbiovar%wwbio%numconfig)

!! this is where the linear equation solver is called to solve S*abio'=abio to get our  abio'
!! parallelize over internuclear coordinate

    aouttr(:,:)=TRANSPOSE(abio(:,:))

    clow = (myrank-1)*inbiovar%bionr/nprocs+1;  chigh = myrank*inbiovar%bionr/nprocs

#ifdef REALGO
    call dgelss(inbiovar%wwbio%numconfig,inbiovar%wwbio%numconfig,chigh-clow+1,&
         Sconfig,inbiovar%wwbio%numconfig,aouttr(:,clow),inbiovar%wwbio%numconfig,&
         sing,max(invtol,lntol**inbiovar%wwbio%numpart),rank,work,lwork,iflag)
#else
    call zgelss(inbiovar%wwbio%numconfig,inbiovar%wwbio%numconfig,chigh-clow+1,&
         Sconfig,inbiovar%wwbio%numconfig,aouttr(:,clow),inbiovar%wwbio%numconfig,&
         sing,max(invtol,lntol**inbiovar%wwbio%numpart),rank,work,lwork,rwork,iflag)
#endif

    if(iflag.ne.0) then
       OFLWR "Stopping due to bad iflag in nonsparsebiortho: ",iflag; CFLST
    endif

    do jproc=1,nprocs
       clow = (jproc-1)*inbiovar%bionr/nprocs+1
       chigh = jproc*inbiovar%bionr/nprocs
       cnum = (chigh-clow+1)*inbiovar%wwbio%numconfig
       call mympibcast(aouttr(:,clow:),jproc,cnum)
    enddo

    aout(:,:)=TRANSPOSE(aouttr(:,:))

    deallocate( bioconfiglist, bioeleclist, smobig, &
         Stmpbig, Sconfig, aouttr, work, sing, rwork )

  contains

    subroutine get_petite_mat(M,N,A,B,left,right)
!! input :
!! M - the dimension of A
!! N - the dimension of B
!! A - an M by M matrix
!! left - an integer list containing all the LHS elements of A to keep in B (N long)
!! right - an integer list containing all the RHS elements of A to keep in B (N long)
!! output : 
!! B - an N by N matrix that is a subset of A
      implicit none
      integer,intent(in) :: M,N,left(N),right(N)
      DATATYPE,intent(in) :: A(M,M)
      DATATYPE,intent(out) :: B(N,N)
      integer :: i,j

      B(:,:)=0d0
      do i=1,N
         do j=1,N
            B(i,j)=A(left(i),right(j))
         enddo
      enddo
    end subroutine get_petite_mat


    function matdet(N,A)
!subroutine getdet(N,A,matdet)
!! this gets a determinant based off of LU decomposition of square matrix A
!! A = PLU : det(A)=det(P)*det(L)*det(U)
!! ?getrf uses Doolittle factorization to get L and U
!! input :
!! N - dimension of A
!! A - an N by N matrix
!! output :
!! matdet - the determinat of A, if anything goes bad, it just returns a value of 0d0
      implicit none
      integer,intent(in) :: N
      integer :: info,i,pow
      integer :: ipiv(N)
      DATATYPE,intent(in) :: A(N,N)
      DATATYPE :: matdet

!! rank 0 or less is not sufficient for a matrix, boo to your input!
      if(N.le.0) then
         matdet=0d0
!! if A is 1x1, ?getrf will just return A, so save the effort
      else if(N.eq.1) then
         matdet=A(1,1)
      else
!! go the actual ?getrf because we need to 

         call MYGETRF(N,N,A,N,ipiv,info)
!! this is the regular case where the factorization worked
!! in Doolittle factorization the diagonal of L=1 => det(L)=1
!! off-diagonal of L and whole of U are stored in A => det(U)=Prod_i{A(i,i)} 
!! det(P)=(-1)**num_row_swaps
!! if ipiv(i).ne.i then row was swapped, last row can't be swapped
         if(info.eq.0) then
            pow=0
            matdet=A(N,N)
            do i=1,N-1
               matdet=matdet*A(i,i)
               if(ipiv(i).ne.i) pow=pow+1
            enddo
            matdet=matdet*((-1d0)**pow)
!! this case is just the matrix is singular
         else if(info.gt.0) then
            matdet=0d0
!! this case is that the ?getrf had an error, so out comes zero
         else 
            matdet=0d0
         endif
      endif

    end function matdet

  end subroutine abio_nonsparse


!! on input:  origmo and abio wave function;  oppmo orbitals to biorthogonalize against
!!   output : origmos have been transformed to mobio, and abio transformed in place

  subroutine biortho(origmo,oppmo,mobio,abio,inbiovar)
    use bio_parameters
    use tol_parameters
    use sparse_parameters
    use spfsize_parameters
    use biorthotypemod
    use abiosparsemod
    use fileptrmod
    use dotmod
    use invsubmod
    use lnsubmod
    use orbgathersubmod
    use utilmod
    implicit none
    type(biorthotype),target,intent(inout) :: inbiovar
    DATATYPE,intent(in) :: origmo(spfsize,inbiovar%wwbio%nspf),oppmo(spfsize,inbiovar%wwbio%nspf)
    DATATYPE,intent(out) :: mobio(spfsize,inbiovar%wwbio%nspf)
    DATATYPE,intent(inout) :: abio(inbiovar%bionr,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig)
    DATATYPE :: atmp(inbiovar%bionr,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig+1),&
         smosave(inbiovar%wwbio%nspf,inbiovar%wwbio%nspf)                           !! AUTOMATIC
    integer :: i,j,lowspf,highspf,numspf,flag

    atmp=0; smosave=0

    lowspf=1;highspf=inbiovar%wwbio%nspf
    if (parorbsplit.eq.1) then
       call checkorbsetrange(inbiovar%wwbio%nspf,flag)
       if (flag.ne.0) then
          OFLWR "error exit, can't do biortho parorbsplit.eq.1 with ",inbiovar%wwbio%nspf," orbitals";CFLST
       endif
       call getOrbSetRange(lowspf,highspf)
    endif
    numspf=highspf-lowspf+1

    if (inbiovar%hermonly) then
       do i=lowspf,highspf
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(j)
!$OMP DO SCHEDULE(DYNAMIC)
          do j=1,inbiovar%wwbio%nspf
             inbiovar%smo(j,i)=hermdot(oppmo(:,j),origmo(:,i),spfsize)
          enddo
!$OMP END DO
!$OMP END PARALLEL
       enddo
    else
       do i=lowspf,highspf
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(j)
!$OMP DO SCHEDULE(DYNAMIC)
          do j=1,inbiovar%wwbio%nspf
             inbiovar%smo(j,i)=dot(oppmo(:,j),origmo(:,i),spfsize)
          enddo
!$OMP END DO
!$OMP END PARALLEL
       enddo
    endif

    if (parorbsplit.eq.1) then
       call mpiorbgather(inbiovar%smo(:,:),inbiovar%wwbio%nspf)
    endif
    if (parorbsplit.eq.3) then
       call mympireduce(inbiovar%smo,inbiovar%wwbio%nspf**2)
    endif
    
!! make the  bi-orthonormal orbitals 
    smosave(:,:)=inbiovar%smo(:,:)
    call invmatsmooth(inbiovar%smo,inbiovar%wwbio%nspf,inbiovar%wwbio%nspf,lntol,.false.);   
    call MYGEMM('N','N',spfsize,inbiovar%wwbio%nspf,inbiovar%wwbio%nspf,DATAONE,origmo,spfsize,&
         inbiovar%smo,inbiovar%wwbio%nspf,DATAZERO,mobio,spfsize)
    
!! check the biorthonormalization to be within hardwired tolerance 1d-10
!! training wheels turned off by KVL for speed on larger jobs
!do i=1,inbiovar%wwbio%nspf
!  do j=1,inbiovar%wwbio%nspf
!    data0=dot(oppmo(:,i),mobio(:,j),biospfsize);    val=0d0;   if(i.eq.j) val=1d0
!    if(abs(real(data0))-val      .gt.1d-10) print *, 'bad real ',i,j,data0 
!    if(abs(imag(data0+(0d0,0d0))).gt.1d-10) print *, 'bad imag ',i,j,data0 
!  enddo
!enddo
!! do the a-vector backtransform, sparse or nonsparse
    
    if(inbiovar%wwbio%sparseconfigflag.eq.0) then
       call abio_nonsparse(abio,atmp,inbiovar)
    else
       inbiovar%smo(:,:)=smosave(:,:)
       call lnmat(inbiovar%smo(:,:),inbiovar%wwbio%nspf) 
       call abio_sparse(abio,atmp,inbiovar)
    endif
    
!!$ hangs sometimes (n2) uncertain why yet
!!$  if (mod(icalled,1000).eq.0) then
!!$ call checkbio(origmo,mobio,abio,atmp,biospfsize,inbiovar%wwbio%nspf,nr)
!!$  endif
    
    if (inbiovar%wwbio%lastconfig.ge.inbiovar%wwbio%firstconfig) then
       abio(:,:)=atmp(:,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig)
    endif

  end subroutine biortho

!! given origmo and abio wave function, transform abio such that it is now coefficients of mobio.
!!   i.e. operate with S-inverse on a-vector from s computed from input orbs

  subroutine biotransform(origmo,oppmo,abio,inbiovar)
    use fileptrmod
    use spfsize_parameters
    use sparse_parameters
    use bio_parameters
    use tol_parameters
    use biorthotypemod
    use abiosparsemod
    use dotmod
    use invsubmod
    use lnsubmod
    use orbgathersubmod
    use utilmod
    implicit none
    type(biorthotype),target,intent(inout) :: inbiovar
    DATATYPE,intent(in) :: origmo(spfsize,inbiovar%wwbio%nspf),oppmo(spfsize,inbiovar%wwbio%nspf)
    DATATYPE,intent(inout) :: abio(inbiovar%bionr,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig)
    DATATYPE :: atmp(inbiovar%bionr,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig+1)    !! AUTOMATIC
    integer :: i,j,lowspf,highspf,numspf,flag

    atmp=0

    lowspf=1;highspf=inbiovar%wwbio%nspf
    if (parorbsplit.eq.1) then
       call checkorbsetrange(inbiovar%wwbio%nspf,flag)
       if (flag.ne.0) then
          OFLWR "error exit, can't do biortho parorbsplit.eq.1 with ",&
               inbiovar%wwbio%nspf," orbitals";CFLST
       endif
       call getOrbSetRange(lowspf,highspf)
    endif
    numspf=highspf-lowspf+1

    if (inbiovar%hermonly) then
       do i=lowspf,highspf
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(j)
!$OMP DO SCHEDULE(DYNAMIC)
          do j=1,inbiovar%wwbio%nspf
             inbiovar%smo(j,i)=hermdot(oppmo(:,j),origmo(:,i),spfsize)
          enddo
!$OMP END DO
!$OMP END PARALLEL
       enddo
    else
       do i=lowspf,highspf
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(j)
!$OMP DO SCHEDULE(DYNAMIC)
          do j=1,inbiovar%wwbio%nspf
             inbiovar%smo(j,i)=dot(oppmo(:,j),origmo(:,i),spfsize)
          enddo
!$OMP END DO
!$OMP END PARALLEL
       enddo
    endif

    if (parorbsplit.eq.1) then
       call mpiorbgather(inbiovar%smo(:,:),inbiovar%wwbio%nspf)
    endif
    if (parorbsplit.eq.3) then
       call mympireduce(inbiovar%smo,inbiovar%wwbio%nspf**2)
    endif

    if(inbiovar%wwbio%sparseconfigflag.eq.0) then
       call invmatsmooth(inbiovar%smo,inbiovar%wwbio%nspf,inbiovar%wwbio%nspf,lntol,.false.);   
       call abio_nonsparse(abio,atmp,inbiovar)
    else
       call lnmat(inbiovar%smo,inbiovar%wwbio%nspf)
       call abio_sparse(abio,atmp,inbiovar)
    endif
    if (inbiovar%wwbio%lastconfig.ge.inbiovar%wwbio%firstconfig) then
       abio(:,:)=atmp(:,inbiovar%wwbio%firstconfig:inbiovar%wwbio%lastconfig)
    endif
  end subroutine biotransform

end module biorthomod




!!$  !! NOW for nat check, not biortho.  ONLY FOR DEBUG, HANGS.
!!$  
!!$  subroutine checkbio(origmo,mobio,abio,atmp)
!!$    use parameters
!!$    implicit none
!!$    DATATYPE :: mobio(spfsize,nspf), origmo(spfsize,nspf), atmp(num_config,numr), abio(num_config,numr), checkoverlap, check1,check2
!!$    integer, save :: icalled=-1
!!$    real*8 :: err
!!$    icalled=icalled+1
!!$  
!!$    OFLWR "SOMETHING IS UP.  BIOTRANSFORM DEFINITELY WORKS BUT CHECKBIO 
!!$        DOES NOT AGREE. AUTOCORRELATE_ONE LIKELY BROKEN."; CFLST
!!$  
!!$    call openfile(); write(mpifileptr,*) "   .... check biortho perm " ; call closefile()
!!$  
!!$    call permoverlaps(numr,num2part,spfsize,origmo,mobio,abio,atmp,checkoverlap,&
!!$          0,0.d-8,0.d-8,nspf,nspf,num_config,num_config,configlist,num2part,&
!!$          configlist,num2part,0,parorbsplit)
!!$    call permoverlaps(numr,num2part,spfsize,origmo,origmo,abio,abio,check1,0,0.d-8,0.d-8,&
!!$          nspf,nspf,num_config,num_config,configlist,num2part,configlist,num2part,0,parorbsplit)
!!$    call permoverlaps(numr,num2part,spfsize,mobio,mobio,atmp,atmp,check2,0,0.d-8,0.d-8,&
!!$          nspf,nspf,num_config,num_config,configlist,num2part,configlist,num2part,0,parorbsplit)
!!$  
!!$    err=abs((checkoverlap-sqrt(check1*check2))/checkoverlap)
!!$    if (err.gt.1.d-7) then
!!$       OFLWR "Checkbio: FAIL ", checkoverlap,check1,check2,err,num_config*numr; CFL
!!$    else
!!$       OFLWR "Checkbio: err",err; CFL
!!$    endif
!!$  
!!$  end subroutine checkbio


!! OLD OLD OLD
!! this is hanging sometimes.... disabling above
!!$ 
!!$ subroutine checkbio(origmo,mobio,abio,atmp,insize,norb,nr)
!!$   use biorthomod
!!$   use mpimod
!!$   implicit none
!!$   DATATYPE :: mobio(insize,norb), origmo(insize,norb), atmp(num_config,nr), abio(num_config,nr),&
!!$        checkoverlap, check1,check2
!!$   integer, save :: icalled=-1
!!$   integer :: nr,insize,norb
!!$   real*8 :: err
!!$   icalled=icalled+1
!!$ 
!!$ !!  call openfile(); write(mpifileptr,*) "   .... check biortho perm " ; call closefile()
!!$ 
!!$   call permoverlaps(nr,num2part,insize,origmo,mobio,abio,atmp,checkoverlap,0,0.d-8,0.d-8,&
!!$         norb,norb,num_config,num_config,configlist,num2part,configlist,num2part,0)
!!$   call permoverlaps(nr,num2part,insize,origmo,origmo,abio,abio,check1,0,0.d-8,0.d-8,&
!!$         norb,norb,num_config,num_config,configlist,num2part,configlist,num2part,0)
!!$   call permoverlaps(nr,num2part,insize,mobio,mobio,atmp,atmp,check2,0,0.d-8,0.d-8,norb,norb,&
!!$         num_config,num_config,configlist,num2part,configlist,num2part,0)
!!$ 
!!$   err=abs((checkoverlap-sqrt(check1*check2))/checkoverlap)
!!$   if (err.gt.1.d-6) then
!!$      OFLWR "PERM FAIL ", checkoverlap,check1,check2,err,num_config*nr; CFL
!!$   else
!!$      OFLWR "Checkbio: err",err; CFL
!!$   endif
!!$ end subroutine checkbio






