!!$
!!$Apache License
!!$                           Version 2.0, January 2004
!!$                        http://www.apache.org/licenses/
!!$
!!$   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
!!$
!!$   1. Definitions.
!!$
!!$      "License" shall mean the terms and conditions for use, reproduction,
!!$      and distribution as defined by Sections 1 through 9 of this document.
!!$
!!$      "Licensor" shall mean the copyright owner or entity authorized by
!!$      the copyright owner that is granting the License.
!!$
!!$      "Legal Entity" shall mean the union of the acting entity and all
!!$      other entities that control, are controlled by, or are under common
!!$      control with that entity. For the purposes of this definition,
!!$      "control" means (i) the power, direct or indirect, to cause the
!!$      direction or management of such entity, whether by contract or
!!$      otherwise, or (ii) ownership of fifty percent (50%) or more of the
!!$      outstanding shares, or (iii) beneficial ownership of such entity.
!!$
!!$      "You" (or "Your") shall mean an individual or Legal Entity
!!$      exercising permissions granted by this License.
!!$
!!$      "Source" form shall mean the preferred form for making modifications,
!!$      including but not limited to software source code, documentation
!!$      source, and configuration files.
!!$
!!$      "Object" form shall mean any form resulting from mechanical
!!$      transformation or translation of a Source form, including but
!!$      not limited to compiled object code, generated documentation,
!!$      and conversions to other media types.
!!$
!!$      "Work" shall mean the work of authorship, whether in Source or
!!$      Object form, made available under the License, as indicated by a
!!$      copyright notice that is included in or attached to the work
!!$      (an example is provided in the Appendix below).
!!$
!!$      "Derivative Works" shall mean any work, whether in Source or Object
!!$      form, that is based on (or derived from) the Work and for which the
!!$      editorial revisions, annotations, elaborations, or other modifications
!!$      represent, as a whole, an original work of authorship. For the purposes
!!$      of this License, Derivative Works shall not include works that remain
!!$      separable from, or merely link (or bind by name) to the interfaces of,
!!$      the Work and Derivative Works thereof.
!!$
!!$      "Contribution" shall mean any work of authorship, including
!!$      the original version of the Work and any modifications or additions
!!$      to that Work or Derivative Works thereof, that is intentionally
!!$      submitted to Licensor for inclusion in the Work by the copyright owner
!!$      or by an individual or Legal Entity authorized to submit on behalf of
!!$      the copyright owner. For the purposes of this definition, "submitted"
!!$      means any form of electronic, verbal, or written communication sent
!!$      to the Licensor or its representatives, including but not limited to
!!$      communication on electronic mailing lists, source code control systems,
!!$      and issue tracking systems that are managed by, or on behalf of, the
!!$      Licensor for the purpose of discussing and improving the Work, but
!!$      excluding communication that is conspicuously marked or otherwise
!!$      designated in writing by the copyright owner as "Not a Contribution."
!!$
!!$      "Contributor" shall mean Licensor and any individual or Legal Entity
!!$      on behalf of whom a Contribution has been received by Licensor and
!!$      subsequently incorporated within the Work.
!!$
!!$   2. Grant of Copyright License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      copyright license to reproduce, prepare Derivative Works of,
!!$      publicly display, publicly perform, sublicense, and distribute the
!!$      Work and such Derivative Works in Source or Object form.
!!$
!!$   3. Grant of Patent License. Subject to the terms and conditions of
!!$      this License, each Contributor hereby grants to You a perpetual,
!!$      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
!!$      (except as stated in this section) patent license to make, have made,
!!$      use, offer to sell, sell, import, and otherwise transfer the Work,
!!$      where such license applies only to those patent claims licensable
!!$      by such Contributor that are necessarily infringed by their
!!$      Contribution(s) alone or by combination of their Contribution(s)
!!$      with the Work to which such Contribution(s) was submitted. If You
!!$      institute patent litigation against any entity (including a
!!$      cross-claim or counterclaim in a lawsuit) alleging that the Work
!!$      or a Contribution incorporated within the Work constitutes direct
!!$      or contributory patent infringement, then any patent licenses
!!$      granted to You under this License for that Work shall terminate
!!$      as of the date such litigation is filed.
!!$
!!$   4. Redistribution. You may reproduce and distribute copies of the
!!$      Work or Derivative Works thereof in any medium, with or without
!!$      modifications, and in Source or Object form, provided that You
!!$      meet the following conditions:
!!$
!!$      (a) You must give any other recipients of the Work or
!!$          Derivative Works a copy of this License; and
!!$
!!$      (b) You must cause any modified files to carry prominent notices
!!$          stating that You changed the files; and
!!$
!!$      (c) You must retain, in the Source form of any Derivative Works
!!$          that You distribute, all copyright, patent, trademark, and
!!$          attribution notices from the Source form of the Work,
!!$          excluding those notices that do not pertain to any part of
!!$          the Derivative Works; and
!!$
!!$      (d) If the Work includes a "NOTICE" text file as part of its
!!$          distribution, then any Derivative Works that You distribute must
!!$          include a readable copy of the attribution notices contained
!!$          within such NOTICE file, excluding those notices that do not
!!$          pertain to any part of the Derivative Works, in at least one
!!$          of the following places: within a NOTICE text file distributed
!!$          as part of the Derivative Works; within the Source form or
!!$          documentation, if provided along with the Derivative Works; or,
!!$          within a display generated by the Derivative Works, if and
!!$          wherever such third-party notices normally appear. The contents
!!$          of the NOTICE file are for informational purposes only and
!!$          do not modify the License. You may add Your own attribution
!!$          notices within Derivative Works that You distribute, alongside
!!$          or as an addendum to the NOTICE text from the Work, provided
!!$          that such additional attribution notices cannot be construed
!!$          as modifying the License.
!!$
!!$      You may add Your own copyright statement to Your modifications and
!!$      may provide additional or different license terms and conditions
!!$      for use, reproduction, or distribution of Your modifications, or
!!$      for any such Derivative Works as a whole, provided Your use,
!!$      reproduction, and distribution of the Work otherwise complies with
!!$      the conditions stated in this License.
!!$
!!$   5. Submission of Contributions. Unless You explicitly state otherwise,
!!$      any Contribution intentionally submitted for inclusion in the Work
!!$      by You to the Licensor shall be under the terms and conditions of
!!$      this License, without any additional terms or conditions.
!!$      Notwithstanding the above, nothing herein shall supersede or modify
!!$      the terms of any separate license agreement you may have executed
!!$      with Licensor regarding such Contributions.
!!$
!!$   6. Trademarks. This License does not grant permission to use the trade
!!$      names, trademarks, service marks, or product names of the Licensor,
!!$      except as required for reasonable and customary use in describing the
!!$      origin of the Work and reproducing the content of the NOTICE file.
!!$
!!$   7. Disclaimer of Warranty. Unless required by applicable law or
!!$      agreed to in writing, Licensor provides the Work (and each
!!$      Contributor provides its Contributions) on an "AS IS" BASIS,
!!$      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
!!$      implied, including, without limitation, any warranties or conditions
!!$      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
!!$      PARTICULAR PURPOSE. You are solely responsible for determining the
!!$      appropriateness of using or redistributing the Work and assume any
!!$      risks associated with Your exercise of permissions under this License.
!!$
!!$   8. Limitation of Liability. In no event and under no legal theory,
!!$      whether in tort (including negligence), contract, or otherwise,
!!$      unless required by applicable law (such as deliberate and grossly
!!$      negligent acts) or agreed to in writing, shall any Contributor be
!!$      liable to You for damages, including any direct, indirect, special,
!!$      incidental, or consequential damages of any character arising as a
!!$      result of this License or out of the use or inability to use the
!!$      Work (including but not limited to damages for loss of goodwill,
!!$      work stoppage, computer failure or malfunction, or any and all
!!$      other commercial damages or losses), even if such Contributor
!!$      has been advised of the possibility of such damages.
!!$
!!$   9. Accepting Warranty or Additional Liability. While redistributing
!!$      the Work or Derivative Works thereof, You may choose to offer,
!!$      and charge a fee for, acceptance of support, warranty, indemnity,
!!$      or other liability obligations and/or rights consistent with this
!!$      License. However, in accepting such obligations, You may act only
!!$      on Your own behalf and on Your sole responsibility, not on behalf
!!$      of any other Contributor, and only if You agree to indemnify,
!!$      defend, and hold each Contributor harmless for any liability
!!$      incurred by, or claims asserted against, such Contributor by reason
!!$      of your accepting any such warranty or additional liability.
!!$
!!$   END OF TERMS AND CONDITIONS
!!$
!!$   Copyright 2017 the regents of the University of California
!!$
!!$   Licensed under the Apache License, Version 2.0 (the "License");
!!$   you may not use this file except in compliance with the License.
!!$   You may obtain a copy of the License at
!!$
!!$       http://www.apache.org/licenses/LICENSE-2.0
!!$
!!$   Unless required by applicable law or agreed to in writing, software
!!$   distributed under the License is distributed on an "AS IS" BASIS,
!!$   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!$   See the License for the specific language governing permissions and
!!$   limitations under the License.


#include "Definitions.INC"

  
program mctdhf
  use parameters
  use mpimod
  use xxxmod
  use opmod !! frozenspfs
  use configmod
  use configpropmod
  use configsubmod
  use savenormmod
  use quadavecmod
  use configstuffmod
  use utilmod
  use repnatmod
  use getstuffmod
  use proploopmod
  use configloadmod
  use focksubmod
  use fockrepsubmod
  use cathopsubmod
  use loadstuffmod
  use meansubmod
  use finalstatsubmod
  use spfsubmod
  use getparammod
  implicit none

  integer :: i,spfsloaded,totread,ifile,readnum,qq
  DATAECS, allocatable ::  tempvals(:)
  DATATYPE, allocatable :: bigavector(:,:,:), bigspfs(:,:),hugeavector(:,:),nullvector(:,:,:)
  logical :: logcheckpar

  spfsloaded=0
  pi=4.d0*atan(1.d0)
  do i=1,SLN
     nullbuff(i:i)=" "
  enddo

  call system("mkdir -p Dat"); call system("mkdir -p Bin"); call system("mkdir -p Flux")
  call system("mkdir -p WALKS");  

  open(nullfileptr,file="/dev/null",status="unknown")

  call MPIstart()

  if (myrank.eq.1) then
     call system("date")
  endif

  call checkstopfile()

  call openfile()
  write(mpifileptr, *) " ****************************************************************************"     
  write(mpifileptr, *) " **********************  BEGIN LBNL-AMO-MCTDHF ******************************"
  write(mpifileptr, *) " ****************************************************************************"     
  write(mpifileptr, *) 
  write(mpifileptr, *) "      Atomic/Diatomic/Cartesian Polyatomic nonadiabatic MCTDHF code"
  write(mpifileptr, *) "  for ultrafast electronic and nuclear dynamics in intense laser fields"
  write(mpifileptr, *) "             AMO Theory Group, Lawrence Berkeley Laboratory"
  write(mpifileptr, *) "         D J Haxton,   K V Lawler,   J Jones,   B Abeln,   X Li"
  write(mpifileptr, *) 
  write(mpifileptr, *) "                             VERSION 1.35 "
  write(mpifileptr, *) "       Copyright 2017 the regents of the University of California"
  write(mpifileptr, *)
#ifdef REALGO
  write(mpifileptr, *) "               This is MCTDH: Real-valued version."
#else
#ifdef CNORMFLAG
  write(mpifileptr, *) "               This is CMCTDH: C-NORMed ECS version."
#else
#ifdef ECSFLAG
  write(mpifileptr, *) "               This is CHMCTDH: HERM-normed ECS version."
#else
  write(mpifileptr, *) "               This is PMCTDH: HERM-normed non-ECS version."
#endif
#endif
#endif
  write(mpifileptr, *) 
  write(mpifileptr, *) "               PROCESSOR ",myrank," OF ",nprocs
  write(mpifileptr, *) 
  call closefile()

!! inpfile input; others output

  call getinpfile()
  call getmyparams(mpifileptr,inpfile,spfdims,spfdimtype,reducedpotsize,&
       numr,nucrepulsion,nonuc_checkflag) 
  spfsize=spfdims(1)*spfdims(2)*spfdims(3)

  
  allocate(bondpoints(numr),bondweights(numr),elecweights(spfdims(1),&
       spfdims(2),spfdims(3),3),elecradii(spfsize))
  bondpoints=0; bondweights=0; elecweights=0; elecradii=0

  call getparams()
  call system("mkdir -p "//timingdir)  

  totspfdim=nspf*spfsize

  call transferparams(nspf,spfrestrictflag,spfmvals,spfugrestrict,&
       spfugvals,spfsmallsize,logcheckpar)
  if (logcheckpar) then
     if (parorbsplit.ne.3) then
        OFLWR "Please set parorbsplit=3 - you have orbital parallelization in your project";CFLST
     endif
  else
     if (parorbsplit.eq.3) then
        OFLWR "You don't have orbital parallelization in the coordinate system dependent routine."
        WRFL "   ..don't set parorbsplit=3"; CFLST
     endif
  endif

  if (spfsmallsize.gt.spfsize) then
     OFLWR "smallsize messup.",spfsmallsize,spfsize; CFLST
  endif

  call getclasses()

!!$  if (parorbsplit.eq.1) then
  call mpiorbsets()
!!$  endif

  if ((sparseconfigflag.eq.0).and.(num_config.gt.1000).and.(nosparseforce.eq.0)) then
     OFLWR "You should really turn sparseconfigflag on, with ", &
          num_config*numr, "configurations.";     CFLST
  endif

  OFLWR
  WRFL "************************************"
  WRFL "********  MAIN WALKS  **************"
  WRFL "************************************"
  WRFL; CFL

  if (df_restrictflag.eq.0.or.sparsedfflag.eq.0) then
     use_dfwalktype=.false.
  else
     use_dfwalktype=.true.
  endif

  if (scalarflag.ne.0.or.improvedfockflag.ne.0) then
     use_fockmatrix=.true.
  else
     use_fockmatrix=.false.
  endif

  www%parconsplit=par_consplit

  www%numelec=numelec
  www%holeflag=holeflag
  www%numpart=numpart
  www%num2part=num2part

  www%nspf=nspf

  www%allspinproject=all_spinproject
  www%restrictms=restrict_ms
  www%sss%spinrestrictval=spin_restrictval

  www%dfrestrictflag=df_restrictflag
  www%dflevel=0
  www%dfwalklevel=df_restrictflag
  www%singlewalkflag=1
  www%doublewalkflag=1

  call fast_newconfiglist(www,.true.,.true.)

  num_config=www%numconfig
  allocate(configs_perproc(nprocs))
  configs_perproc(:)=www%configsperproc(:)
  first_config=www%firstconfig
  last_config=www%lastconfig
  local_nconfig=www%localnconfig
  tot_adim=local_nconfig*numr;  

  call walks_and_basis(www)

  if (use_fockmatrix) then

     OFLWR
     WRFL "************************************"
     WRFL "**         CATION WALKS           **"
     WRFL "************************************"
     WRFL; CFL

     catww%parconsplit=par_consplit

     catww%numelec=numelec-1
     catww%holeflag=holeflag
     if (catww%holeflag.eq.0) then
        catww%numpart=numpart-1
        catww%num2part=num2part-2
     else
        catww%numpart=numpart+1
        catww%num2part=num2part+2
     endif
     catww%nspf=nspf

     catww%allspinproject=all_spinproject
!! going up in spin.  arbitrary choice for restrict_ms.ne.0.  
!! could average with another walktype variable for restrict_ms.ne.0
     if (restrict_ms.ge.0) then
        catww%restrictms=restrict_ms+1
     else
        catww%restrictms=restrict_ms-1
     endif
     catww%sss%spinrestrictval=spin_restrictval+1

     catww%dfrestrictflag=max(df_restrictflag-1,0)
     catww%dflevel=max(df_restrictflag-1,0)
     catww%dfwalklevel=max(df_restrictflag-1,0)
     catww%singlewalkflag=1
     catww%doublewalkflag=1

     call fast_newconfiglist(catww,.false.,.false.)

     call walks_and_basis(catww)

     call getcathops()

  endif

!! WALKTYPE VARIABLE BIOWW FOR BIORTHO

!! always use biortho (single walks only) (bwwptr removed)

     OFLWR
     WRFL "************************************"
     WRFL "**        BIORTHO WALKS           **"
     WRFL "************************************"
     WRFL; CFL

     bioww%parconsplit=par_consplit

     bioww%numelec=numelec
     bioww%holeflag=holeflag
     bioww%numpart=numpart
     bioww%num2part=num2part

     bioww%nspf=nspf

     bioww%allspinproject=all_spinproject
     bioww%restrictms=restrict_ms
     bioww%sss%spinrestrictval=spin_restrictval

     bioww%dfrestrictflag=0
     bioww%dflevel=0
     bioww%dfwalklevel=0
     bioww%singlewalkflag=1
     bioww%doublewalkflag=0

     call fast_newconfiglist(bioww,.false.,.true.)

     call walks_and_basis(bioww)

!!! END SET BIOWW !!

!!$  endif

  if (use_dfwalktype) then

     OFLWR
     WRFL "************************************"
     WRFL "*** done biortho walks. DF WALKS ***"
     WRFL "************************************"
     WRFL; CFL

     if (.not.shuffle_dfwalktype) then

!! WALKTYPE VARIABLE DFWW FOR DFRESTRICT

        dfww%parconsplit=par_consplit

        dfww%numelec=numelec
        dfww%holeflag=holeflag
        dfww%numpart=numpart
        dfww%num2part=num2part

        dfww%nspf=nspf

        dfww%allspinproject=all_spinproject
        dfww%restrictms=restrict_ms
        dfww%sss%spinrestrictval=spin_restrictval

        dfww%dfrestrictflag=df_restrictflag
        dfww%dflevel=df_restrictflag
        dfww%dfwalklevel=df_restrictflag
        dfww%singlewalkflag=1
        dfww%doublewalkflag=1

        call set_newconfiglist(www,dfww,.true.)

        call walks_and_basis(dfww)

!!! END SET DFWW !!

     else     !! if shuffle_dfwalktype then:

!! WALKTYPE VARIABLE FDWW FOR DFRESTRICT

        fdww%parconsplit=par_consplit

        fdww%numelec=numelec
        fdww%holeflag=holeflag
        fdww%numpart=numpart
        fdww%num2part=num2part

        fdww%nspf=nspf

        fdww%allspinproject=all_spinproject
        fdww%restrictms=restrict_ms
        fdww%sss%spinrestrictval=spin_restrictval

        fdww%dfrestrictflag=df_restrictflag
        fdww%dflevel=df_restrictflag
        fdww%dfwalklevel=df_restrictflag
        fdww%singlewalkflag=1
        fdww%doublewalkflag=1

        call fast_newconfiglist(fdww,.true.,.true.)

        call walks_and_basis(fdww)

     endif

     OFLWR "   .. DONE setting DF walk variable.";CFL

!!! END SET FDWW !!

  endif

  OFLWR
  WRFL "************************************"
  WRFL "********** DONE WALKS. *************"
  WRFL "************************************"
  WRFL; CFL

!!!!!! REINSTATE WALKS READ/WRITE (walkwriteflag) !!!!!!

  call configpropalloc()

  call xalloc() !!   INITIALIZE XXX/YYY VECTORS!  

!!$  if (use_biowalktype) then
!!$     bwwptr => bioww
!!$  else
!!$     bwwptr => www
!!$  endif

  if (.not.use_dfwalktype) then
     dwwptr => www
     yyy%sptrptr => yyysptr
     worksparsepointerptr => worksparsepointer
  else
     if (shuffle_dfwalktype) then
        dwwptr => fdww
        yyy%sptrptr => yyysfdptr
        worksparsepointerptr => workfdsparsepointer
     else
        dwwptr => dfww
        yyy%sptrptr => yyysdfptr
        worksparsepointerptr => workdfsparsepointer
     endif
  endif

  if (all_spinproject.eq.0) then
     OFLWR "     DWWPTR Slater determinants by processor"
  else
     OFLWR "     DWWPTR Spin-adapted configurations by processor"
  endif
  do i=1,dwwptr%nzprocs
     write (mpifileptr,'(T5,2I7,i20)') i,dwwptr%nzproclist(i),dwwptr%nzconfsperproc(i)
  enddo
  WRFL; CFL

  call opalloc()

  call myprojectalloc()      !! Initialize coordinate-dependent arrays.

  allocate(bigspfs(spfsize,nspf+numfrozen));    bigspfs=0

!! oct 2015 loading orbitals if skipflag equals 1 (in case need frozen)

  if (skipflag.lt.2) then
     if (loadspfflag.eq.1) then
        call load_spfs(bigspfs(:,:),spfsloaded)
        if (numfrozen.gt.0) then
           frozenspfs(:,:)=bigspfs(:,1:numfrozen)
           spfsloaded=spfsloaded-numfrozen
           bigspfs(:,1:nspf)=bigspfs(:,numfrozen+1:numfrozen+nspf)
        endif
     endif  ! loadspfflag
  endif

  OFLWR "Calling init_project",sizeof(pot); CFL
  call init_project(bigspfs,spfsloaded,pot,halfniumpot,rkemod,proderivmod,skipflag,&
       bondpoints,bondweights,elecweights,elecradii,numelec,&
       numfrozen,frozenspfs,frozenkediag,frozenpotdiag,frozenreduced,hatomreduced)
  call mpibarrier()
  OFLWR "   ....Called init_project."; CFL

  if (skipflag.lt.2) then
   
     call spf_orthogit_gs(bigspfs(:,:))
     if (messflag.ne.0) then
        call mess_with_spfs(bigspfs)
        call spf_orthogit_gs(bigspfs(:,:))
     endif

     yyy%cmfspfs(:,0) = RESHAPE(bigspfs(:,1:nspf),(/totspfdim/))
     
     call apply_spf_constraints(yyy%cmfspfs(:,0))
     call spf_orthogit_gs(yyy%cmfspfs(:,0))

  endif  !! skipflag.lt.2

  deallocate(bigspfs)

  if (tot_adim.gt.0) then
     yyy%cmfavec(:,:,0)=0d0
  endif

  allocate(savenorms(numr,mcscfnum))
  savenorms(:,:)=1d0

!! MAY 2014 now not doing load avector if skipflag=1 (flux)

  if (skipflag.eq.0) then

     allocate(bigavector(numr,first_config:last_config,mcscfnum),nullvector(numr,1,mcscfnum))
     nullvector=0d0
     if (tot_adim.gt.0) then
        bigavector(:,:,:)=0d0
     endif
     totread=0

     if (loadavectorflag.eq.1) then
        if (load_avector_product.ne.0) then
           OFLWR "Reading product avector!" ; CFL
           call load_avector_productsub(bigavector)
           readnum=mcscfnum; totread=mcscfnum
        else
        do ifile=1,numavectorfiles
           if (totread.lt.mcscfnum) then
              OFLWR "Reading avector..." ; CFL
              if (tot_adim.gt.0) then
                 call load_avectors(avectorfile(ifile),bigavector(:,:,totread+1),&
                      mcscfnum-totread,readnum,avecloadskip(ifile),totread)
              else
                 call load_avectors(avectorfile(ifile),nullvector(:,:,totread+1),&
                      mcscfnum-totread,readnum,avecloadskip(ifile),totread)
              endif
           endif
           totread=totread+readnum
        enddo
        endif
        OFLWR "Read ",totread," A-vectors"; CFL
     endif

     if (normboflag.ne.0) then
        if (totread.lt.mcscfnum) then
           OFLWR "enforcing BO norms with normboflag, but not enough vectors loaded", mcscfnum
           CFLST
        endif
        OFLWR "    ... will enforce BO norms due to normboflag"
        WRFL "         vectors loaded are then discarded."; CFL
        call get_bonorms(mcscfnum,bigavector,savenorms)
        totread=0
     endif


     if (totread.lt.mcscfnum) then
        if (improvedrelaxflag.eq.0.and.loadavectorflag.ne.0) then
           OFLWR "Loading avectors, but not enough on file for prop..."; CFLST
        endif

        OFLWR "Not enough avectors loaded! will diagonalize."; CFL
        allocate(hugeavector(numr,num_config));   hugeavector=0
        do i=totread+1,mcscfnum
           call staticvector(hugeavector(:,:),num_config*numr)
           if (tot_adim.gt.0) then
              bigavector(:,:,i)=hugeavector(:,first_config:last_config)
           endif
!! gram-schmidt might not be valid if vectors are not orthog but whatever it does not really matter
           if (par_consplit.ne.0) then
              if (tot_adim.gt.0) then
                 call gramschmidt(tot_adim,i-1,tot_adim,bigavector(:,:,:),bigavector(:,:,i),.true.)
              else
                 call gramschmidt(tot_adim,i-1,tot_adim,nullvector(:,:,:),nullvector(:,:,i),.true.)
              endif
           else
              call gramschmidt(tot_adim,i-1,tot_adim,bigavector(:,:,:),bigavector(:,:,i),.false.)
           endif
        enddo
        deallocate(hugeavector)

        if (debugflag.gt.0) then
           call mpibarrier();     OFLWR "CALL ALL MATEL IN MAIN"; CFL;     call mpibarrier()
        endif
!! FIRST CALL ALL MATEL (MANY SEGFAULTS HAPPEN HERE)
        call all_matel()

        if (debugflag.gt.0) then
           call mpibarrier();     OFLWR "AFTER CALL ALL MATEL IN MAIN"; CFL;     call mpibarrier()
        endif

        allocate(tempvals(mcscfnum)); tempvals=0
        if (totread.lt.1) then
           call myconfigeig(yyy%cptr(0),bigavector,tempvals,mcscfnum,1,&
                0,0d0,max(0,abs(improvedrelaxflag)-1))
           if (followflag.ne.0.and.improvedrelaxflag.gt.1) then
              OFLWR "With followflag now setting improvedrelaxflag=1"; CFL
              improvedrelaxflag=1
           endif
        else if (followflag.ne.0) then
           call myconfigeig(yyy%cptr(0),bigavector,tempvals,mcscfnum,1,&
                2,0d0,max(0,abs(improvedrelaxflag)-1))
        else
           call myconfigeig(yyy%cptr(0),bigavector,tempvals,mcscfnum,1,&
                1,0d0,max(0,abs(improvedrelaxflag)-1))
        endif
        if (tot_adim.gt.0) then
           yyy%cmfavec(:,:,0) = RESHAPE(bigavector(:,:,:),(/tot_adim,mcscfnum/))
        endif

        call get_allden()
        if (use_fockmatrix) then
           call get_fockmatrix()
        endif
        if (improvednatflag.ne.0.or.improvedfockflag.ne.0) then
           if (improvednatflag.ne.0) then
              call replace_withnat(1)
           elseif (improvedfockflag.ne.0) then
              call replace_withfock(1)
           endif
           call all_matel()
        
!! since biorthogonalization is imperfect with restricted configuration spaces
!!  and subject to tolerance criteria in any case, go ahead and rediagonalize

!! this is problematic however for restricted config spaces especiall with 
!! improvedrelaxflag>1 because states change.  So do quad if called for.  v1.28

           if (tot_adim.gt.0) then
              bigavector(:,:,:)=RESHAPE(yyy%cmfavec(:,:,0),(/numr,local_nconfig,mcscfnum/))
           endif
           if ((improvedquadflag.eq.1.or.improvedquadflag.eq.3).and.0d0.ge.aquadstarttime) then
              call quadavector(bigavector,qq)
           else
              if (followflag.ne.0) then
                 call myconfigeig(yyy%cptr(0),bigavector,tempvals,mcscfnum,1,&
                      2,0d0,max(0,abs(improvedrelaxflag)-1))
              else
                 call myconfigeig(yyy%cptr(0),bigavector,tempvals,mcscfnum,1,&
                      1,0d0,max(0,abs(improvedrelaxflag)-1))
              endif
           endif
        endif
        deallocate(tempvals)
     endif  
     if (tot_adim.gt.0) then
        yyy%cmfavec(:,:,0) = RESHAPE(bigavector(:,:,:),(/tot_adim,mcscfnum/))
     endif
     deallocate(bigavector)
  endif

  if (messavec.ne.0) then
     allocate(hugeavector(numr*num_config,1));  hugeavector=0
     do i=1,mcscfnum
        call staticvector(hugeavector(:,:),num_config*numr)
        if (tot_adim.gt.0) then
           yyy%cmfavec(:,i,0) = yyy%cmfavec(:,i,0) + messaamount * &
                hugeavector((first_config-1)*numr+1:last_config*numr,1) / &
                sqrt(real(num_config*numr))
        endif
     enddo
     deallocate(hugeavector)
  endif

  if (cdenflag.ne.0) then
     call natprojalloc()
  endif

!! *************************************************************** !!
!!   ACTIONS_INITIAL: PUT ANALYSIS ROUTINES HERE; THEN TERMINATES. !!
!! *************************************************************** !!

  if (skipflag.eq.0) then
     call get_stuff(0d0)
  endif
  call actions_initial()                 
  if (skipflag.ne.0) then
     OFLWR "Stopping after actions_initial"; CFLST
  endif
                                         
!! *************************************************************** !!
!! ************************* CORE ROUTINE ************************ !!

  call prop_loop( 0.d0 )

!! *************************************************************** !!

  if (threshflag.ne.0) then
     OFLWR "   ...getting state expectation values etcetera..."; CFL
     call mpibarrier()
     call finalstats()
  endif

!! *********************** !!

!  OFLWR "   ...cleanup..."; CFL

!! 10-2015 something is buggy... no need to explicitly deallocate so commenting out - djh
!  call opdealloc()
!
!!!  call myprojectdealloc()  ;  
!
!  call twoedealloc();     
!  call xdealloc()
!
!  deallocate(myavectorhole,myavectorexcitefrom,myavectorexciteto)
!
!  call dfcondealloc()
!  call natprojdealloc(); 

  call mpibarrier()
  call waitawhile()
  if (myrank.eq.1) then
     call system("date")
  endif
  call mpibarrier()
  call waitawhile()
  OFLWR "   ...END MCTDHF"; CFLST

contains
  subroutine walks_and_basis(wwin)
    use walksubmod
    use spininitmod
    use spinwalkinternal
    implicit none
    type(walktype),intent(inout) :: wwin

    call walkalloc(wwin)
    call walks(wwin)
    call hops(wwin)
    call set_matsize(wwin)
    call init_dfcon(wwin)

!!!! NO LONGER NEED THESE
    OFLWR "Deallocating walks arrays."; CFL
    deallocate(wwin%singlewalk, wwin%doublewalk)

    call spinwalkinit(wwin)
    call spinwalks(wwin)
    call spinsets_first(wwin)
    call configspin_matel(wwin)
    call configspinset_projector(wwin)
    call spinwalkinternal_dealloc()
    call basis_set(wwin,nzflag)
  end subroutine walks_and_basis

subroutine getclasses()
  use parameters
  use class_parameters
  implicit none
  integer :: iclass,ispf,jspf,flag

  allocate(orbclass(nspf));   orbclass=0

  iclass=0
  do ispf=1,nspf
     flag=0
     do jspf=1,ispf-1
        
        if ( (spfrestrictflag.eq.0.or.spfmvals(jspf).eq.spfmvals(ispf)) .and. &
             (spfugrestrict.eq.0.or.spfugvals(jspf).eq.spfugvals(ispf)) ) then
           orbclass(ispf)=orbclass(jspf)
           flag=1
           exit
        endif
     enddo
     if (flag.eq.0) then
        iclass=iclass+1
        orbclass(ispf)=iclass
     endif
  enddo

  numclasses=iclass
  allocate(classorb(nspf,numclasses),nperclass(numclasses))
  classorb=0; nperclass=0

  do iclass=1,numclasses
     jspf=0
     do ispf=1,nspf
        if (orbclass(ispf).eq.iclass) then
           jspf=jspf+1
           classorb(jspf,iclass)=ispf
        endif
     enddo
     nperclass(iclass)=jspf
  enddo
!  OFLWR "NPERCLASS", nperclass
!  WRFL
!  WRFL "CLASSORB"
!  do iclass=1,numclasses
!     WRFL classorb(1:nperclass(iclass),iclass)
!  enddo

end subroutine getclasses

end program mctdhf

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


